
services:
  mqtt:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
    volumes:
      - ./services/mqtt-bridge/mosquitto.dev.conf:/mosquitto/config/mosquitto.conf:ro
      - ./services/mqtt-bridge/passwords:/mosquitto/config/passwords:ro
      - ./services/mqtt-bridge/acl:/mosquitto/config/acl:ro
      - mqtt_data:/mosquitto/data
      - mqtt_logs:/mosquitto/log
    healthcheck:
      # Используем простую проверку TCP порта вместо создания MQTT подключения
      # Это избегает создания временных подключений с auto-{UUID}
      test: ["CMD-SHELL", "nc -z localhost 1883 || exit 1"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
  db:
    image: timescale/timescaledb:latest-pg16
    environment:
      POSTGRES_PASSWORD: hydro
      POSTGRES_USER: hydro
      POSTGRES_DB: hydro_dev
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - wal_archive:/wal_archive
    # WAL архивирование отключено в dev окружении для упрощения
    # В production используйте правильную команду архивирования
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U hydro -d hydro_dev"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s
  laravel:
    build:
      context: ./laravel
      dockerfile: Dockerfile
      args:
        INSTALL_DEV_DEPS: "true"
    working_dir: /app
    # docker-entrypoint.sh will handle supervisor startup automatically
    # Base image will start nginx/php-fpm via its default entrypoint
    environment:
      - WEB_DOCUMENT_ROOT=/app/public
      - APP_ENV=local
      - APP_DEBUG=true
      - APP_DEBUG_MODE=true
      - SESSION_DRIVER=file
      - CACHE_DRIVER=file
      - SESSION_SAME_SITE=lax
      - SESSION_SECURE_COOKIE=false
      - LOG_CHANNEL=stderr
      - LOG_LEVEL=debug
      # PHP error display settings for development
      - PHP_DISPLAY_ERRORS=On
      - PHP_DISPLAY_STARTUP_ERRORS=On
      - PHP_ERROR_REPORTING=E_ALL
      - BROADCAST_CONNECTION=reverb
      - QUEUE_CONNECTION=redis
      - DB_CONNECTION=pgsql
      - DB_HOST=db
      - DB_PORT=5432
      - DB_DATABASE=hydro_dev
      - DB_USERNAME=hydro
      - DB_PASSWORD=hydro
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REVERB_APP_ID=app
      - REVERB_APP_KEY=local
      - REVERB_APP_SECRET=secret
      - REVERB_SERVER_HOST=0.0.0.0
      - REVERB_SERVER_PORT=6001
      - REVERB_SERVER_PATH=
      # REVERB_HOST должен быть localhost для клиента (не 0.0.0.0)
      # 0.0.0.0 используется только для REVERB_SERVER_HOST (прослушивание сервера)
      # localhost используется для клиентских подключений через nginx прокси
      - REVERB_HOST=localhost
      - REVERB_PORT=6001
      - REVERB_SCHEME=http
      # Явно указываем REVERB_CLIENT_HOST для клиентских подключений
      - REVERB_CLIENT_HOST=localhost
      - REVERB_DEBUG=true
      - REVERB_AUTO_START=true
      - REVERB_VERBOSE=true
      - REVERB_ALLOWED_ORIGINS=http://localhost:8080,http://127.0.0.1:8080,http://localhost:5173,http://127.0.0.1:5173,http://localhost,http://127.0.0.1,*
      # Устанавливаем VITE_DEV_SERVER_URL для правильной генерации URL Laravel Vite plugin
      # Используем localhost:8080 (через nginx прокси), а не 0.0.0.0, так как браузер не может использовать 0.0.0.0
      # Для доступа с телефона установите VITE_DEV_SERVER_URL=http://YOUR_IP:8080
      # где YOUR_IP - IP адрес вашего компьютера в локальной сети
      - VITE_DEV_SERVER_URL=${VITE_DEV_SERVER_URL:-"http://localhost:8080"}
      # Vite environment variables for WebSocket
      - VITE_ENABLE_WS=true
      - VITE_REVERB_APP_KEY=local
      # Vite dev mode settings - включить детальное отображение ошибок
      - NODE_ENV=development
      - VITE_NODE_ENV=development
      # Включить sourcemaps и детальное логирование
      - VITE_SOURCEMAP=true
      - VITE_LOG_LEVEL=info
      # В dev режиме НЕ указываем VITE_REVERB_HOST и VITE_REVERB_PORT
      # чтобы клиент использовал window.location (nginx прокси на порту 8080)
      # Nginx проксирует WebSocket на /app/ к Reverb на порту 6001
      - VITE_REVERB_SCHEME=http
      - VITE_PUSHER_APP_KEY=local
      # В dev режиме НЕ указываем VITE_WS_HOST и VITE_WS_PORT
      # чтобы клиент использовал window.location (nginx прокси)
      - VITE_WS_TLS=false
      # Python services token (must be set via environment variable or .env file)
      # Never commit actual tokens to version control
      # ⚠️ ВАЖНО: dev-token-12345 - это известный dev-токен для разработки
      # ⚠️ ОБЯЗАТЕЛЬНО переопределите все токены в production!
      # ⚠️ Использование этого токена в production создает критическую уязвимость безопасности
      - PY_API_TOKEN=${PY_API_TOKEN:-dev-token-12345}
      - PY_INGEST_TOKEN=${PY_INGEST_TOKEN:-dev-token-12345}
      - LARAVEL_API_TOKEN=${LARAVEL_API_TOKEN:-dev-token-12345}
      # MQTT configuration
      # MQTT_EXTERNAL_HOST - IP адрес хоста для внешних подключений (ESP32 ноды)
      # Если не указан, будет использоваться MQTT_HOST (имя сервиса для внутренних подключений)
      # По умолчанию используем IP хоста, определенный автоматически при запуске
      - MQTT_EXTERNAL_HOST=${MQTT_EXTERNAL_HOST:-192.168.1.115}
      - MQTT_HOST=${MQTT_HOST:-mqtt}
      - MQTT_PORT=${MQTT_PORT:-1883}
      # PHP opcache settings for development (disable caching)
      - PHP_OPCACHE_ENABLE=0
      - PHP_OPCACHE_VALIDATE_TIMESTAMPS=1
      - PHP_OPCACHE_REVALIDATE_FREQ=0
      # PHP-FPM оптимизация для снижения нагрузки на CPU
      - PHP_FPM_PM=dynamic
      - PHP_FPM_PM_MAX_CHILDREN=5
      - PHP_FPM_PM_START_SERVERS=2
      - PHP_FPM_PM_MIN_SPARE_SERVERS=1
      - PHP_FPM_PM_MAX_SPARE_SERVERS=3
      - PHP_FPM_PM_MAX_REQUESTS=500
    volumes:
      - ./laravel:/app
      # Монтируем конфигурацию nginx для Vite прокси, чтобы изменения применялись без пересборки
      - ./laravel/nginx-vite-proxy.conf:/opt/docker/etc/nginx/vhost.common.d/vite-proxy.conf:ro
    ports:
      - "8080:80"
      - "5173:5173"
      - "6001:6001"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:80/api/system/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
  mqtt-bridge:
    build:
      context: ./services
      dockerfile: mqtt-bridge/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
      - MQTT_TLS=0
      - MQTT_USER=mqtt_bridge
      - MQTT_PASS=bridge_pass
      - PG_HOST=db
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - LARAVEL_API_URL=http://laravel
      # ⚠️ ВАЖНО: dev-token-12345 - это известный dev-токен для разработки
      # ⚠️ ОБЯЗАТЕЛЬНО переопределите в production!
      - PY_API_TOKEN=${PY_API_TOKEN:-dev-token-12345}
      - LARAVEL_API_TOKEN=${LARAVEL_API_TOKEN:-dev-token-12345}
    depends_on:
      mqtt:
        condition: service_healthy
      db:
        condition: service_healthy
      laravel:
        condition: service_healthy
    ports:
      - "9000:9000"
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(1); s.connect((\"localhost\", 9000)); s.close()' || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
    restart: unless-stopped
  history-logger:
    build:
      context: ./services
      dockerfile: history-logger/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
      - MQTT_TLS=0
      - MQTT_USER=history_logger
      - MQTT_PASS=logger_pass
      - PG_HOST=db
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - LARAVEL_API_URL=http://laravel
      # ⚠️ ВАЖНО: dev-токены для разработки, ОБЯЗАТЕЛЬНО переопределите в production!
      - PY_API_TOKEN=${PY_API_TOKEN:-dev-token-12345}
      - PY_INGEST_TOKEN=${PY_INGEST_TOKEN:-dev-token-12345}
      - HISTORY_LOGGER_API_TOKEN=${HISTORY_LOGGER_API_TOKEN:-${PY_INGEST_TOKEN:-dev-token-12345}}
      - LARAVEL_API_TOKEN=${LARAVEL_API_TOKEN:-dev-token-12345}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      mqtt:
        condition: service_healthy
      db:
        condition: service_healthy
      laravel:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "9300:9300"
      - "9301:9301"  # Prometheus metrics
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(1); s.connect((\"localhost\", 9300)); s.close()' || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
    restart: unless-stopped
  automation-engine:
    build:
      context: ./services
      dockerfile: automation-engine/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
      - MQTT_TLS=0
      - MQTT_USER=automation_engine
      - MQTT_PASS=automation_pass
      - PG_HOST=db
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - LARAVEL_API_URL=http://laravel
      # ⚠️ ВАЖНО: dev-токены для разработки, ОБЯЗАТЕЛЬНО переопределите в production!
      - PY_API_TOKEN=${PY_API_TOKEN:-dev-token-12345}
      - LARAVEL_API_TOKEN=${LARAVEL_API_TOKEN:-dev-token-12345}
    depends_on:
      mqtt:
        condition: service_healthy
      db:
        condition: service_healthy
      laravel:
        condition: service_healthy
    ports:
      - "9401:9401"
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(1); s.connect((\"localhost\", 9401)); s.close()' || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped
  scheduler:
    build:
      context: ./services
      dockerfile: scheduler/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
      - MQTT_TLS=0
      - MQTT_USER=scheduler
      - MQTT_PASS=scheduler_pass
      - PG_HOST=db
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
    depends_on:
      mqtt:
        condition: service_healthy
      db:
        condition: service_healthy
    ports:
      - "9402:9402"
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(1); s.connect((\"localhost\", 9402)); s.close()' || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    volumes:
      - ./configs/dev/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./configs/dev/prometheus/alerts.yml:/etc/prometheus/alerts.yml:ro
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    depends_on:
      automation-engine:
        condition: service_healthy
      scheduler:
        condition: service_healthy
      mqtt-bridge:
        condition: service_healthy
    restart: unless-stopped
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
      # Плагин grafana-clock-panel отключен из-за проблем с установкой (403 Forbidden)
      # - GF_INSTALL_PLUGINS=grafana-clock-panel
      - GF_DEFAULT_LANGUAGE=ru
      - GF_USERS_DEFAULT_LANGUAGE=ru
    volumes:
      - ./configs/dev/grafana/datasources.yml:/etc/grafana/provisioning/datasources/datasources.yml:ro
      - ./configs/dev/grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./configs/dev/grafana/dashboards:/var/lib/grafana/dashboards:ro
      - ./configs/dev/grafana/grafana.ini:/etc/grafana/grafana.ini:ro
      - grafana_data:/var/lib/grafana
    ports:
      - "3000:3000"
    depends_on:
      prometheus:
        condition: service_started
      db:
        condition: service_healthy
    restart: unless-stopped
    logging:
      driver: "none"
  alertmanager:
    image: prom/alertmanager:latest
    container_name: alertmanager
    command:
      - '--config.file=/etc/alertmanager/config.yml'
      - '--storage.path=/alertmanager'
    volumes:
      - ./configs/dev/alertmanager/config.yml:/etc/alertmanager/config.yml:ro
      - alertmanager_data:/alertmanager
    ports:
      - "9093:9093"
    depends_on:
      prometheus:
        condition: service_started
      laravel:
        condition: service_healthy
    restart: unless-stopped
    logging:
      driver: "none"

  digital-twin:
    build:
      context: ./services
      dockerfile: digital-twin/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - PG_HOST=db
      - PG_PORT=5432
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - PYTHONPATH=/app
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "8003:8003"
      - "9403:9403"  # Prometheus metrics
    restart: unless-stopped

  telemetry-aggregator:
    build:
      context: ./services
      dockerfile: telemetry-aggregator/Dockerfile
    environment:
      - APP_ENV=local
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1
      - PG_HOST=db
      - PG_PORT=5432
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - PYTHONPATH=/app
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "9404:9404"  # Prometheus metrics
    restart: unless-stopped

  python-tests:
    build:
      context: ./services
      dockerfile: Dockerfile.test
    environment:
      - PG_HOST=db
      - PG_PORT=5432
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - PYTHONPATH=/app
    depends_on:
      - db
    volumes:
      - ./services:/app
    profiles:
      - tests
    command: ["python", "-m", "pytest", "common/test_metrics.py", "common/test_alerts.py", "common/test_telemetry_phase2.py", "automation-engine/test_alerts_manager_phase2.py", "-v"]
  
  # Контейнер для запуска PID тестов
  pid-tests:
    build:
      context: ./services
      dockerfile: Dockerfile.test
    environment:
      - PG_HOST=db
      - PG_PORT=5432
      - PG_DB=hydro_dev
      - PG_USER=hydro
      - PG_PASS=hydro
      - PYTHONPATH=/app
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./services:/app
    profiles:
      - tests
    command: ["python", "-m", "pytest", "automation-engine/tests/test_pid_config_service.py", "automation-engine/tests/test_pid_config_service_cache_update.py", "automation-engine/tests/test_pid_config_type_safety.py", "automation-engine/tests/test_zone_automation_pid_cleanup.py", "automation-engine/test_pid_integration.py", "-v"]

volumes:
  postgres_data:
  prometheus_data:
  grafana_data:
  alertmanager_data:
  wal_archive:
  mqtt_data:
  mqtt_logs:

networks:
  default:
    name: backend_default
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.0/16
