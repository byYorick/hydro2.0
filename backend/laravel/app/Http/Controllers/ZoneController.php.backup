<?php

namespace App\Http\Controllers;

use App\Helpers\ZoneAccessHelper;
use App\Models\Zone;
use App\Services\ZoneService;
use App\Services\ZoneReadinessService;
use App\Services\EffectiveTargetsService;
use App\Services\ZoneLifecycleService;
use App\Services\ZoneOperationsService;
use App\Services\ZoneDataService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Schema;

class ZoneController extends Controller
{
    public function __construct(
        private ZoneService $zoneService,
        private ZoneReadinessService $readinessService,
        private EffectiveTargetsService $effectiveTargetsService,
        private ZoneLifecycleService $lifecycleService,
        private ZoneOperationsService $operationsService,
        private ZoneDataService $dataService
    ) {
    }

    /**
     * Проверить авторизацию и доступ к зоне
     */
    private function authorizeZoneAccess($user, Zone $zone): void
    {
        if (!$user) {
            abort(401, 'Unauthorized');
        }

        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            abort(403, 'Forbidden: Access denied to this zone');
        }
    }

    public function index(Request $request): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        // Получаем доступные зоны для пользователя
        $accessibleZoneIds = ZoneAccessHelper::getAccessibleZoneIds($user);
        
        // Валидация query параметров
        $validated = $request->validate([
            'greenhouse_id' => ['nullable', 'integer', 'exists:greenhouses,id'],
            'status' => ['nullable', 'string', 'in:online,offline,warning'],
            'search' => ['nullable', 'string', 'max:255'],
        ]);
        
        // Eager loading для предотвращения N+1 запросов
        $query = Zone::query()
            ->withCount('nodes') // Счетчик узлов
            ->with(['greenhouse:id,name', 'preset:id,name']); // Загружаем только нужные поля
        
        // Фильтруем зоны по доступным для пользователя
        if (!$user->isAdmin()) {
            $query->whereIn('id', $accessibleZoneIds);
        }
        
        if (isset($validated['greenhouse_id'])) {
            // Дополнительно проверяем доступ к теплице
            if (!$user->isAdmin() && !ZoneAccessHelper::canAccessGreenhouse($user, $validated['greenhouse_id'])) {
                return response()->json([
                    'status' => 'error',
                    'message' => 'Forbidden: Access denied to this greenhouse',
                ], 403);
            }
            $query->where('greenhouse_id', $validated['greenhouse_id']);
        }
        if (isset($validated['status'])) {
            $query->where('status', $validated['status']);
        }
        
        // Поиск по имени или описанию
        if (isset($validated['search']) && $validated['search']) {
            // Экранируем специальные символы LIKE для защиты от SQL injection
            $searchTerm = addcslashes($validated['search'], '%_');
            $query->where(function ($q) use ($searchTerm) {
                $q->where('name', 'ILIKE', "%{$searchTerm}%")
                  ->orWhere('description', 'ILIKE', "%{$searchTerm}%");
            });
        }
        
        $items = $query->latest('id')->paginate(25);
        return response()->json(['status' => 'ok', 'data' => $items]);
    }

    public function store(Request $request): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        $data = $request->validate([
            'greenhouse_id' => ['nullable', 'integer', 'exists:greenhouses,id'],
            'preset_id' => ['nullable', 'integer', 'exists:presets,id'],
            'name' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string'],
            'status' => ['nullable', 'string', 'max:32'],
        ]);
        
        // Проверяем доступ к теплице, если указана
        if (isset($data['greenhouse_id'])) {
            if (!ZoneAccessHelper::canAccessGreenhouse($user, $data['greenhouse_id'])) {
                return response()->json([
                    'status' => 'error',
                    'message' => 'Forbidden: Access denied to this greenhouse',
                ], 403);
            }
        }
        
        $zone = $this->zoneService->create($data);
        return response()->json(['status' => 'ok', 'data' => $zone], Response::HTTP_CREATED);
    }

    public function show(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        // Проверяем доступ к зоне
        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this zone',
            ], 403);
        }
        
        $zone->load(['greenhouse', 'preset', 'nodes', 'activeGrowCycle.currentPhase', 'activeGrowCycle.recipeRevision']);
        return response()->json(['status' => 'ok', 'data' => $zone]);
    }

    public function update(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        // Проверяем доступ к зоне
        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this zone',
            ], 403);
        }
        
        $data = $request->validate([
            'greenhouse_id' => ['nullable', 'integer', 'exists:greenhouses,id'],
            'name' => ['sometimes', 'string', 'max:255'],
            'description' => ['nullable', 'string'],
            'status' => ['nullable', 'string', 'max:32'],
        ]);
        
        // Проверяем доступ к новой теплице, если меняется
        if (isset($data['greenhouse_id']) && $data['greenhouse_id'] !== $zone->greenhouse_id) {
            if (!ZoneAccessHelper::canAccessGreenhouse($user, $data['greenhouse_id'])) {
                return response()->json([
                    'status' => 'error',
                    'message' => 'Forbidden: Access denied to target greenhouse',
                ], 403);
            }
        }
        
        $zone = $this->zoneService->update($zone, $data);
        return response()->json(['status' => 'ok', 'data' => $zone]);
    }

    public function destroy(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        // Проверяем доступ к зоне
        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this zone',
            ], 403);
        }
        
        try {
            $this->zoneService->delete($zone);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    public function attachRecipe(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $data = $request->validate([
            'recipe_id' => ['required', 'integer', 'exists:recipes,id'],
            'start_at' => ['nullable', 'date'],
        ]);

        try {
            $instance = $this->lifecycleService->attachRecipe(
                $zone,
                $data['recipe_id'],
                isset($data['start_at']) ? new \DateTime($data['start_at']) : null
            );

            // Загружаем обновленную зону с активным циклом
            $zone->refresh();
            $zone->load(['activeGrowCycle.recipeRevision']);

            return response()->json([
                'status' => 'ok',
                'data' => [
                    'zone_id' => $zone->id,
                    'recipe_instance_id' => $instance->id,
                    'recipe_id' => $instance->recipe_id,
                ]
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to attach recipe', [
                'zone_id' => $zone->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    public function changePhase(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $data = $request->validate([
            'phase_index' => ['required', 'integer', 'min:0'],
        ]);

        try {
            $this->lifecycleService->changePhase($zone, $data['phase_index']);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    public function nextPhase(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        try {
            $this->lifecycleService->nextPhase($zone);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    public function pause(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        try {
            $this->lifecycleService->pause($zone);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    public function resume(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        try {
            $this->lifecycleService->resume($zone);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    /**
     * Завершить grow-cycle (harvest)
     * POST /api/zones/{zone}/harvest
     */
    public function harvest(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        try {
            $this->lifecycleService->harvest($zone);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
    }

    /**
     * Запустить grow-cycle для зоны
     * POST /api/zones/{zone}/start
     */
    public function start(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        try {
            $this->lifecycleService->start($zone, []);
            return response()->json(['status' => 'ok']);
        } catch (\DomainException $e) {
            return response()->json([
                'status' => 'error',
                'message' => $e->getMessage(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        }
                'status' => 'ok',
                'data' => [
                    'zone_id' => $zone->id,
                    'status' => $zone->status,
                    'warnings' => $readiness['warnings'],
                ],
            ]);
        });
    }

    public function health(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $health = $this->operationsService->getHealth($zone);

        return response()->json([
            'status' => 'ok',
            'data' => $health,
        ]);
    }

    public function fill(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $data = $request->validate([
            'target_level' => ['required', 'numeric', 'min:0.1', 'max:1.0'],
            'max_duration_sec' => ['nullable', 'integer', 'min:10', 'max:600'],
        ]);

        $jobId = $this->operationsService->fill($zone, $data);

        return response()->json([
            'status' => 'ok',
            'message' => 'Fill operation queued',
            'job_id' => $jobId,
        ], Response::HTTP_ACCEPTED);
    }

    public function drain(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $data = $request->validate([
            'target_level' => ['required', 'numeric', 'min:0.0', 'max:0.9'],
            'max_duration_sec' => ['nullable', 'integer', 'min:10', 'max:600'],
        ]);

        $jobId = $this->operationsService->drain($zone, $data);

        return response()->json([
            'status' => 'ok',
            'message' => 'Drain operation queued',
            'job_id' => $jobId,
        ], Response::HTTP_ACCEPTED);
    }

    public function calibrateFlow(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }
        
        // Проверяем доступ к зоне
        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this zone',
            ], 403);
        }
        
        $data = $request->validate([
            'node_id' => ['required', 'integer', 'exists:nodes,id'],
            'channel' => ['required', 'string', 'max:128'],
            'pump_duration_sec' => ['nullable', 'integer', 'min:5', 'max:60'],
        ]);
        
        // Проверяем доступ к ноде
        $node = \App\Models\DeviceNode::find($data['node_id']);
        if ($node && !ZoneAccessHelper::canAccessNode($user, $node)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this node',
            ], 403);
        }

        // Выполняем операцию асинхронно через очередь для предотвращения блокировки PHP-FPM
        $jobId = \Illuminate\Support\Str::uuid()->toString();
        \App\Jobs\ZoneOperationJob::dispatch($zone->id, 'calibrateFlow', $data, $jobId);
        
        return response()->json([
            'status' => 'ok',
            'message' => 'Calibrate flow operation queued',
            'job_id' => $jobId,
        ], Response::HTTP_ACCEPTED);
    }

    /**
     * Получить информацию о циклах зоны
     * GET /api/zones/{id}/cycles
     */
    public function cycles(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $result = $this->dataService->getCycles($zone, $request);

        return response()->json([
            'status' => 'ok',
            'data' => $result,
        ]);
    }

    /**
     * Получить unassigned errors для зоны
     * GET /api/zones/{zone}/unassigned-errors
     */
    public function unassignedErrors(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $result = $this->dataService->getUnassignedErrors($zone, $request);

        return response()->json([
            'status' => 'ok',
            'data' => $result,
        ]);
    }

    /**
     * Получить snapshot состояния зоны для восстановления после reconnect
     * GET /api/zones/{zone}/snapshot
     * 
     * Возвращает:
     * - latest telemetry (per node/channel)
     * - active alerts
     * - last N commands + statuses
     * - device online/offline status
     * - server_ts + snapshot_id
     */
    public function snapshot(Request $request, Zone $zone): JsonResponse
    {
        $this->authorizeZoneAccess($request->user(), $zone);

        $snapshot = $this->dataService->getSnapshot($zone, $request);

        return response()->json([
            'status' => 'ok',
            'data' => $snapshot,
        ]);
                $telemetry[$nodeId][$channel] = [];
            }
            
            $telemetry[$nodeId][$channel][] = [
                'metric_type' => $item->metric_type,
                'value' => $item->value,
                'updated_at' => $item->updated_at?->toIso8601String(),
            ];
        }

        // Получаем активные алерты
        $activeAlerts = \App\Models\Alert::query()
            ->where('zone_id', $zone->id)
            ->where('status', 'ACTIVE')
            ->select(['id', 'code', 'type', 'details', 'status', 'created_at'])
            ->orderBy('created_at', 'desc')
            ->get()
            ->map(function ($alert) {
                return [
                    'id' => $alert->id,
                    'code' => $alert->code,
                    'type' => $alert->type,
                    'details' => $alert->details,
                    'status' => $alert->status,
                    'created_at' => $alert->created_at?->toIso8601String(),
                ];
            });

            // Получаем последние N команд (по умолчанию 50)
            $commandsLimit = min($request->input('commands_limit', 50), 200);
            
            // Проверяем наличие расширенных полей в таблице commands
            $columns = DB::getSchemaBuilder()->getColumnListing('commands');
            $hasExtendedFields = in_array('error_code', $columns);
            
            $recentCommands = \App\Models\Command::query()
                ->where('zone_id', $zone->id)
                ->select([
                    'id',
                    'cmd_id',
                    'cmd',
                    'status',
                    'node_id',
                    'channel',
                    'params',
                    'sent_at',
                    'ack_at',
                    'failed_at',
                    ...($hasExtendedFields ? ['error_code', 'error_message', 'result_code', 'duration_ms'] : []),
                ])
                ->orderBy('created_at', 'desc')
                ->limit($commandsLimit)
                ->get()
                ->map(function ($command) use ($hasExtendedFields) {
                    $result = [
                        'id' => $command->id,
                        'cmd_id' => $command->cmd_id,
                        'cmd' => $command->cmd,
                        'status' => $command->status,
                        'node_id' => $command->node_id,
                        'channel' => $command->channel,
                        'params' => $command->params,
                        'sent_at' => $command->sent_at?->toIso8601String(),
                        'ack_at' => $command->ack_at?->toIso8601String(),
                        'failed_at' => $command->failed_at?->toIso8601String(),
                    ];
                    
                    if ($hasExtendedFields) {
                        $result['error_code'] = $command->error_code;
                        $result['error_message'] = $command->error_message;
                        $result['result_code'] = $command->result_code;
                        $result['duration_ms'] = $command->duration_ms;
                    }
                    
                    return $result;
                });

            // Получаем статусы устройств (online/offline) - devices_online_state
            $devicesOnlineState = $zone->nodes()
                ->select(['id', 'uid', 'name', 'type', 'status', 'last_seen_at', 'last_heartbeat_at'])
                ->get()
                ->map(function ($node) {
                    return [
                        'id' => $node->id,
                        'uid' => $node->uid,
                        'name' => $node->name,
                        'type' => $node->type,
                        'status' => $node->status, // online/offline
                        'last_seen_at' => $node->last_seen_at?->toIso8601String(),
                        'last_heartbeat_at' => $node->last_heartbeat_at?->toIso8601String(),
                    ];
                });

            // Реструктурируем телеметрию как latest_telemetry_per_channel
            // Группируем по channel, затем по node_id для удобства клиента
            $latestTelemetryPerChannel = [];
            foreach ($telemetryRaw as $item) {
                $nodeId = $item->node_id ?? 'unknown';
                $channel = $item->channel ?? 'default';
                
                if (!isset($latestTelemetryPerChannel[$channel])) {
                    $latestTelemetryPerChannel[$channel] = [];
                }
                if (!isset($latestTelemetryPerChannel[$channel][$nodeId])) {
                    $latestTelemetryPerChannel[$channel][$nodeId] = [];
                }
                
                $latestTelemetryPerChannel[$channel][$nodeId][] = [
                    'metric_type' => $item->metric_type,
                    'value' => $item->value,
                    'updated_at' => $item->updated_at?->toIso8601String(),
                ];
            }

            // Возвращаем атомарный snapshot с фиксированными server_ts и last_event_id
            // Важно: last_event_id всегда должен присутствовать в ответе для корректной работы E2E тестов
            return response()->json([
                'status' => 'ok',
                'data' => [
                    'snapshot_id' => $snapshotId,
                    'server_ts' => $serverTs,
                    'last_event_id' => (int)$lastEventId, // Курсор событий для catch-up (явно приводим к int)
                    'zone_id' => $zone->id,
                    'devices_online_state' => $devicesOnlineState, // Статусы устройств
                    'active_alerts' => $activeAlerts, // Активные алерты
                    'latest_telemetry_per_channel' => $latestTelemetryPerChannel, // Последняя телеметрия по каналам
                    'commands_recent' => $recentCommands, // Последние команды со статусами
                ],
            ]);
        });
    }

    /**
     * Получить события зоны (Zone Event Ledger).
     * 
     * GET /api/zones/{zone}/events?after_id=...&limit=...
     * 
     * Возвращает отсортированный список событий с поддержкой пагинации по after_id.
     * Используется для синхронизации клиентов, которые пропустили WebSocket события.
     */
    public function events(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json([
                'status' => 'error',
                'message' => 'Unauthorized',
            ], 401);
        }

        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json([
                'status' => 'error',
                'message' => 'Forbidden: Access denied to this zone',
            ], 403);
        }

        // Преобразуем cycle_only в boolean до валидации (может быть строкой "true"/"false" или boolean)
        // Axios передает boolean как строку "true"/"false" в query параметрах
        $cycleOnlyInput = $request->query->get('cycle_only');
        if ($cycleOnlyInput !== null) {
            // Преобразуем строку "true"/"false" в boolean
            $boolValue = filter_var($cycleOnlyInput, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);
            if ($boolValue !== null) {
                // Заменяем значение в query параметрах
                $request->query->set('cycle_only', $boolValue);
            } else {
                // Если не удалось преобразовать, удаляем параметр
                $request->query->remove('cycle_only');
            }
        }
        
        // Валидация query параметров
        $validated = $request->validate([
            'after_id' => ['nullable', 'integer', 'min:0'],  // Разрешаем 0 для начального запроса
            'limit' => ['nullable', 'integer', 'min:1', 'max:1000'],
            'cycle_only' => ['nullable', 'boolean'], // Фильтр для событий цикла
        ]);

        $afterId = $validated['after_id'] ?? null;
        $limit = min($validated['limit'] ?? 50, 200); // Максимум 200 для E2E, по умолчанию 50
        $cycleOnly = $validated['cycle_only'] ?? false;

        // Запрос событий для зоны
        $query = DB::table('zone_events')
            ->where('zone_id', $zone->id);

        // Фильтр для событий цикла: старт, смена стадии, critical alerts, ручные вмешательства
        if ($cycleOnly) {
            $cycleEventTypes = [
                'CYCLE_CREATED',
                'CYCLE_STARTED',
                'CYCLE_PAUSED',
                'CYCLE_RESUMED',
                'CYCLE_HARVESTED',
                'CYCLE_ABORTED',
                'CYCLE_RECIPE_REBASED',
                'PHASE_TRANSITION',
                'RECIPE_PHASE_CHANGED',
                'ZONE_COMMAND', // Ручные вмешательства
            ];
            
            // Используем where с замыканием для правильной группировки условий
            $query->where(function ($q) use ($cycleEventTypes) {
                $q->whereIn('type', $cycleEventTypes);
            });
            
            // Также включаем critical alerts (ALERT_CREATED с severity CRITICAL)
            // Проверяем, какая колонка существует (payload_json или details) для обратной совместимости
            $hasPayloadJson = DB::getSchemaBuilder()->hasColumn('zone_events', 'payload_json');
            $detailsColumn = $hasPayloadJson ? 'payload_json' : 'details';
            
            $query->orWhere(function ($q) use ($detailsColumn) {
                $q->where('type', 'ALERT_CREATED')
                  ->whereRaw("{$detailsColumn}->>'severity' = 'CRITICAL'");
            });
        } else {
            // Определяем колонку details для случая, когда cycle_only = false
            $hasPayloadJson = DB::getSchemaBuilder()->hasColumn('zone_events', 'payload_json');
            $detailsColumn = $hasPayloadJson ? 'payload_json' : 'details';
        }

        // Убеждаемся, что $detailsColumn определена (если cycle_only = false, она еще не определена)
        if (!isset($detailsColumn)) {
            $hasPayloadJson = DB::getSchemaBuilder()->hasColumn('zone_events', 'payload_json');
            $detailsColumn = $hasPayloadJson ? 'payload_json' : 'details';
        }

        $query->orderBy('id', 'asc'); // Строго по возрастанию id для гарантии порядка

        // Если указан after_id, получаем события после этого ID
        if ($afterId) {
            $query->where('id', '>', $afterId);
        }
        
        $events = $query->limit($limit)->get([
            'id as event_id',
            'zone_id',
            'type',
            DB::raw("{$detailsColumn} as details"),
            'created_at',
        ])->map(function ($event) {
            // Преобразуем details из jsonb в массив, если это строка
            if (is_string($event->details)) {
                $event->details = json_decode($event->details, true) ?? [];
            }
            // Добавляем payload для обратной совместимости
            $event->payload = $event->details;
            return $event;
        });

        // Получаем последний event_id для следующего запроса
        $lastEventId = $events->isNotEmpty() ? $events->last()->event_id : $afterId;

        // Проверяем, есть ли еще события после последнего
        $hasMore = false;
        if ($lastEventId) {
            $hasMore = DB::table('zone_events')
                ->where('zone_id', $zone->id)
                ->where('id', '>', $lastEventId)
                ->exists();
        }

        return response()->json([
            'status' => 'ok',
            'data' => $events->values(),
            'last_event_id' => $lastEventId,
            'has_more' => $hasMore,
        ]);
    }

    /**
     * Обновить инфраструктуру зоны
     */
    public function updateInfrastructure(Request $request, Zone $zone): JsonResponse
    {
        $user = $request->user();
        if (!$user) {
            return response()->json(['status' => 'error', 'message' => 'Unauthorized'], 401);
        }

        if (!ZoneAccessHelper::canAccessZone($user, $zone)) {
            return response()->json(['status' => 'error', 'message' => 'Forbidden'], 403);
        }

        $data = $request->validate([
            'infrastructure' => ['required', 'array'],
            'infrastructure.*.asset_type' => ['required', 'string', 'in:PUMP,MISTER,TANK_NUTRIENT,TANK_CLEAN,DRAIN,LIGHT,VENT,HEATER'],
            'infrastructure.*.label' => ['required', 'string', 'max:255'],
            'infrastructure.*.required' => ['required', 'boolean'],
            'infrastructure.*.capacity_liters' => ['nullable', 'numeric', 'min:0'],
            'infrastructure.*.flow_rate' => ['nullable', 'numeric', 'min:0'],
            'infrastructure.*.specs' => ['nullable', 'array'],
        ]);

        return DB::transaction(function () use ($zone, $data) {
            // Удаляем старую инфраструктуру
            $zone->infrastructure()->delete();

            // Создаем новую
            foreach ($data['infrastructure'] as $assetData) {
                $zone->infrastructure()->create($assetData);
            }

            $zone->refresh();
            $zone->load('infrastructure');

            return response()->json([
                'status' => 'ok',
                'data' => [
                    'zone_id' => $zone->id,
                    'infrastructure' => $zone->infrastructure,
                ],
            ]);
        });
    }
}


