# ALERTS_AND_NOTIFICATIONS_CHANNELS.md
# Каналы уведомлений и связь с алертами

Документ дополняет:
- `EVENTS_AND_ALERTS_ENGINE.md`
- `../04_BACKEND_CORE/REALTIME_UPDATES_ARCH.md`
- `../12_ANDROID_APP/ANDROID_APP_ARCH.md`

и описывает, **как алерты доставляются пользователю**.


Compatible-With: Protocol 2.0, Backend >=3.0, Python >=3.0, Database >=3.0, Frontend >=3.0.
Breaking-change: legacy форматы/алиасы удалены, обратная совместимость не поддерживается.

---

## 1. Источник истины: алерты в backend

- Backend хранит все алерты и их состояние:
 - `open` / `acknowledged` / `resolved` / `suppressed`.
- Любое изменение статуса алерта:
 - фиксируется в БД,
 - генерирует событие `alert_created` или `alert_updated`
 (см. `../04_BACKEND_CORE/REALTIME_UPDATES_ARCH.md`).

---

## 2. Каналы уведомлений

1. **Realtime в UI** (WebSocket):
 - для активных сессий web/Android.
2. **Push-уведомления**:
 - для мобилок, когда приложение в фоне/закрыто.
3. (Опционально) **каналы сторонних интеграций**:
 - email,
 - мессенджеры (Telegram, Slack),
 - SMS.

В 2.0 минимальный гарантированный набор: realtime + push.

---

## 3. Категории алертов и правила уведомлений

Алерты делятся по уровню критичности:

- `info` — информационные события (например, завершена калибровка).
- `warning` — важные, но некритичные отклонения.
- `critical` — критические ситуации:
 - риск потери урожая,
 - серьёзные аварии (утечка, мгновенное падение pH/EC за пределы).

Правила по умолчанию:

- realtime:
 - все открытые алерты видны в UI (список/иконки).
- push:
 - по умолчанию только `critical`;
 - `warning` — по выбору пользователя;
 - `info` — по умолчанию не пушим.

Пользователь может настроить:

- какие уровни отправлять в push;
- по каким теплицам/зонам.

---

## 4. Структура push-уведомления

### 4.1. Общий payload (FCM/другое)

Для FCM-подобных систем:

```json
{
 "notification": {
 "title": "ALERT: pH out of range",
 "body": "Zone A: pH 5.0 below target 6.0–6.5"
 },
 "data": {
 "alert_id": "alert-1",
 "severity": "critical",
 "alert_type": "ph_out_of_range",
 "zone_id": "zone-1",
 "greenhouse_id": "gh-1"
 }
}
```

- `notification` — то, что показывает ОС.
- `data` — используется приложением для навигации
 (открыть нужную зону/алерт).

### 4.2. Логика на клиенте

Клиент при получении пуша:

1. Показывает пользователю уведомление (или тихое в зависимости от настроек).
2. При тапе:
 - открывает экран алерта/зоны,
 - подтягивает детали алерта по REST/WebSocket.

---

## 5. Управление подписками на push

На уровне пользователя:

- в приложении хранятся настройки:
 - интересующие теплицы/зоны,
 - уровни критичности.

На уровне сервера:

- для каждого устройства:
 - храним `device_token` (FCM и т.п.),
 - привязываем к пользователю/аккаунту.

Backend при генерации алерта:

- определяет список пользователей, которых нужно уведомить;
- отправляет пуши только тем устройствам, которые:
 - принадлежат этим пользователям,
 - не отключили соответствующую категорию уведомлений.

---

## 6. Интеграция с realtime-событиями

- `alert_created` → триггер для отправки push (с учетом настроек).
- `alert_updated` (например, `acknowledged` или `resolved`) может:
 - не слать push (обновление видно в UI),
 - либо слать тихое уведомление (настраиваемо).

Решение по поведению по умолчанию фиксируется в бизнес-правилах
и может изменяться без смены протокола.

---

## 7. Требования к ИИ-агенту

1. При доработке алерт-системы ИИ должен:
 - сохранять совместимость структуры `alert_*` событий,
 - описывать, как изменения повлияют на push/realtime.
2. Нельзя:
 - добавлять новые каналы уведомлений без обновления этого документа;
 - «шифровать» важные данные только в текст пуша — всё важное должно быть в `data`.
