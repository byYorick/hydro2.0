# LOGIC_ARCH.md
# Архитектура логики 2.0 (Теплица → Зоны → Циклы выращивания → Рецепты → Ноды → Каналы)

Документ описывает **логическую модель системы 2.0** для управления гидропоникой:
какие сущности существуют, кто за что отвечает и как данные проходят по системе.

**После мега-рефакторинга 2025-12-25 система переведена на новую доменную модель:**
- **Центр истины:** `GrowCycle` (цикл выращивания)
- **Версионирование рецептов:** `RecipeRevision` с фазовыми снапшотами
- **Эффективные targets:** Структурированные данные вместо JSON
- **Единый контракт:** Laravel API для всех Python сервисов

Цель — дать основу, на которой можно:

- проектировать backend и БД;
- проектировать поведение Python-сервиса и нод ESP32;
- строить UI/UX;
- обучать ИИ-агентов корректно расширять систему, не ломая её.


Compatible-With: Protocol 2.0, Backend >=3.0, Python >=3.0, Database >=3.0, Frontend >=3.0.
Breaking-change: legacy форматы/алиасы удалены, обратная совместимость не поддерживается.

---

## 1. Базовые сущности и иерархия

### 1.1. Greenhouse (теплица)

- Логический контейнер верхнего уровня.
- Идентификатор: `greenhouses.uid` → сегмент `{gh}` в MQTT.
- Хранит:
 - набор зон;
 - геолокацию/описание;
 - настройки по умолчанию (часовой пояс, язык, системные лимиты).

### 1.2. Zone (зона)

- Физическое пространство с оборудованием для выращивания.
- Идентификатор: `zones.uid` → сегмент `{zone}` в MQTT.
- Внутри зоны:
 - работает **ровно 1 активный цикл выращивания** (`GrowCycle`);
 - назначены узлы и их каналы;
 - считаются агрегированные метрики (средний pH, EC, температура и т.п.).

**Принцип:** зона — это физический контейнер, агрономическая логика теперь в `GrowCycle`.

### 1.3. GrowCycle (цикл выращивания) — **ЦЕНТР ИСТИНЫ**

- Основная единица агрономической логики (новая модель после рефакторинга).
- Идентификатор: `grow_cycles.id` + связи с `recipe_revision_id`, `current_phase_id`.
- Хранит:
 - ссылку на зафиксированную ревизию рецепта (`RecipeRevision`);
 - текущую фазу (`current_phase_id` → `GrowCyclePhase`);
 - временные метки (started_at, phase_started_at, planting_at);
 - overrides целевых параметров;
 - историю переходов фаз.

**Принцип:** все агрономические решения принимаются **на уровне цикла выращивания**, а не зоны.

### 1.4. Recipe & RecipeRevision (рецепты с версиями)

- `Recipe` — базовый рецепт для растения/культуры.
- `RecipeRevision` — конкретная версия рецепта (DRAFT/PUBLISHED/ARCHIVED).
- `RecipeRevisionPhase` — фазы с целевыми параметрами по колонкам (не JSON).
- `GrowCyclePhase` — снапшот фазы для конкретного цикла.

**Принцип:** рецепты версионируются, активный цикл использует зафиксированную ревизию.

### 1.3. DeviceNode (узел ESP32)

- Физическое устройство ESP32/ESP32-S3.
- Идентификатор: `nodes.uid` → сегмент `{node}` в MQTT.
- Узел:
 - не знает про рецепты;
 - не знает про растения;
 - не хранит агрономические цели;
 - реализует только «физику» каналов: измерить / включить / выключить / установить ШИМ и т.п.

### 1.4. Channel (канал узла)

- Логический порт узла: сенсор или актуатор.
- Идентификатор: `channels.key` → сегмент `{channel}` в MQTT.
- Типы:
 - `SENSOR` — pH, EC, температура, влажность, освещённость и т.п.;
 - `ACTUATOR` — насосы, клапаны, освещение, вентиляторы и т.п.;
 - `VIRTUAL` — вычисляемые метрики (например, усреднённый EC по зоне).

Канал **не знает**, зачем его значение нужно системе. Он лишь измеряет/исполняет.

---

## 2. Роли компонентов логики

### 2.1. ESP32-ноды

Роль: **детерминированные исполнительные устройства**.

- Опрос сенсоров → публикация телеметрии в MQTT.
- Выполнение полученных команд (включить насос, изменить ШИМ, начать калибровку и т.д.).
- Локальные safety-механизмы (таймауты, watchdog, защита от зависания реле).
- Никаких долгих расчётов, ML, рецептов, планировщиков.

### 2.2. Python-сервис (MQTT Router + Cycle Controllers)

Роль: **логический контроллер циклов выращивания**.

- Подписка на весь namespace MQTT (`hydro/#`).
- Разбор телеметрии → запись в БД (см. `../05_DATA_AND_STORAGE/TELEMETRY_PIPELINE.md`).
- Получение **effective targets** через Laravel API (`/api/internal/effective-targets/batch`).
- Запуск контроллеров для активных циклов:
 - pH-контроллер (поддержание целевого pH);
 - EC-контроллер;
 - климат-контроллер (температура, влажность, CO₂);
 - полив/дренаж;
 - освещение.
- Генерация команд для узлов согласно:
 - эффективным целям из активного цикла;
 - текущим измерениям;
 - ограничениям безопасности.

### 2.3. Backend (Laravel)

Роль: **единственный источник истины по конфигурации и истории**.

- Хранит структуру теплиц/зон/узлов/каналов.
- Хранит рецепты, состояния и расписания.
- Хранит историю телеметрии и событий.
- Предоставляет REST/WS API фронтенду, Android и внешним интеграциям.
- Управляет пользователями, правами доступа, журналированием.

### 2.4. UI (Frontend + Android)

Роль: **визуализация и ручное управление**.

- Отображение текущего состояния зон/узлов.
- Просмотр истории телеметрии, аварий, рецептов.
- Ручное вмешательство: включить/выключить насос, изменить целевой pH, поставить зону на паузу и т.п.
- Настройка рецептов и расписаний.

---

## 3. Логические потоки (сверху вниз)

### 3.1. Конфигурация

1. Пользователь через UI создаёт теплицу/зону/узлы и каналы.
2. Агроном создаёт рецепт с ревизиями и запускает цикл выращивания (Wizard).
3. Backend сохраняет конфигурацию в PostgreSQL + создаёт снапшоты фаз (`GrowCyclePhase`).
4. Python-сервис получает effective targets через Laravel API:
 - `/api/internal/effective-targets/batch` — batch запрос для всех активных зон;
 - возвращает цели из текущей фазы активного цикла с учётом overrides.
5. Python-сервис синхронизирует NodeConfig с узлами:
 - через MQTT-команды и/или REST provisioning (см. `NODE_LIFECYCLE_AND_PROVISIONING.md`).

### 3.2. Телеметрия

1. Узел ESP32 по расписанию опрашивает сенсоры.
2. Публикует сообщения вида:

```text
hydro/{gh}/{zone}/{node}/{channel}/telemetry
```

payload:

```json
{
 "value": 5.78,
 "metric": "PH",
 "ts": 1737355600456
}
```

3. Python-сервис:
 - валидирует payload;
 - записывает в `telemetry_samples` и `telemetry_last`;
 - обновляет состояние контроллера зоны (см. `../05_DATA_AND_STORAGE/TELEMETRY_PIPELINE.md`).

4. Backend через БД и/или стримы получает обновления и отдаёт их на UI.

### 3.3. Команды

1. Python-сервис или Backend (через Python API) решает отправить команду узлу.
2. Публикуется сообщение:

```text
hydro/{gh}/{zone}/{node}/{channel}/command
```

payload, например:

```json
{
 "cmd_id": "cmd-2025-01-01-12-00-00-001",
 "cmd": "set_pwm",
 "params": { "value": 128 },
 "ts": 1737355112,
 "sig": "a1b2c3d4e5f6..."
}
```

3. Узел ESP32:
 - читает команду;
 - проверяет ts/sig/валидность;
 - выполняет действие;
 - публикует `status`/`event` с результатом:

```text
hydro/{gh}/{zone}/{node}/{channel}/status
```

```json
{
 "request_id": "cmd-2025-01-01-12-00-00-001",
 "status": "OK",
 "ts": 1737355601123
}
```

---

## 4. Взаимодействие с циклами выращивания (новая модель)

1. **Zone имеет активный цикл** (`grow_cycles` с `recipe_revision_id`).
2. **Цикл имеет текущую фазу** (`current_phase_id` → `GrowCyclePhase` — снапшот).
3. **Фаза содержит цели по колонкам** (ph_target, ec_target, irrigation_mode и т.д.).
4. **Python получает effective targets** через Laravel API (с учётом overrides).
5. **На основании effective targets** формирует команды узлам (через MQTT).

**Ключевые изменения после рефакторинга:**
- Убрана старая модель `zone_recipe_instances` + JSON targets
- Введено версионирование рецептов (`RecipeRevision`)
- Цели хранятся по колонкам, а не в JSON
- Центр истины — `GrowCycle`, а не `Zone`
- Единый контракт через Laravel API для всех Python сервисов

Принцип: **рецепты и фазы никогда не хранятся в узлах** — только в БД (через backend).

---

## 5. Ошибки, аварии и безопасные режимы

- Узлы публикуют события:

```text
hydro/{gh}/{zone}/{node}/{channel}/event
```

payload (пример):

```json
{
 "type": "SENSOR_ERROR",
 "code": "PH_PROBE_DISCONNECTED",
 "ts": 1737355600456
}
```

- Python-сервис:
 - сохраняет событие в БД (`events`, `alerts`);
 - в зависимости от типа может перевести зону в безопасный режим (например, отключить дозаторы).

- Backend:
 - показывает алерты в UI;
 - может отправлять уведомления (Telegram, email и т.п.).

---

## 6. Принципы для ИИ-агентов (после рефакторинга 2025-12-25)

1. **Центр истины — GrowCycle.**
 Любые изменения в агрономической логике должны учитывать модель GrowCycle.

2. **Не переносить бизнес-логику в ESP32.**
 Любые изменения в логике pH/EC/климата — только в Python/Backend через Laravel API.

3. **Использовать Laravel API для Python сервисов.**
 Python сервисы должны получать данные через `/api/internal/*` endpoints, а не прямые SQL запросы.

4. **Не ломать MQTT namespace.**
 Любые новые топики должны соответствовать правилам `../03_TRANSPORT_MQTT/MQTT_NAMESPACE.md`.

5. **Сначала модель данных → потом код.**
 При добавлении новой сущности:
 - прописать её в `../05_DATA_AND_STORAGE/DATA_MODEL_REFERENCE.md`;
 - добавить миграции;
 - обновить Laravel API endpoints;
 - только потом менять Python/ESP32.

6. **Не усложнять схемы команд.**
 Команды должны быть простыми, детерминированными и проверяемыми.

7. **Единая точка истины.**
 Любые настройки/рецепты/пользовательские решения должны храниться в БД, а не в конфиг-файлах ESP32.

8. **Версионировать рецепты.**
 Все изменения рецептов должны идти через `RecipeRevision` с состояниями DRAFT/PUBLISHED.

9. **Тестировать контракты.**
 При изменении Laravel API обязательно обновлять тесты в `tests/Unit/EffectiveTargetsServiceTest.php`.

---

## 7. Краткое резюме логики 2.0 (после рефакторинга)

- **Теплица → Зоны → Циклы выращивания → Рецепты → Узлы → Каналы** — новая иерархия.
- **GrowCycle — центр истины** для агрономической логики.
- **RecipeRevision** обеспечивает версионирование рецептов.
- **Effective targets** — единый контракт через Laravel API.
- ESP32 — минимальные исполнительные устройства без бизнес-логики.
- Python-сервис — контроллер циклов, получает данные через Laravel API.
- Backend — конфигурация, история, пользователи, API с новыми эндпоинтами.
- UI/Android — визуализация и ручное управление циклами.
- **Все решения по pH/EC/климату/поливу принимаются в цикле выращивания, а не в зоне.**
