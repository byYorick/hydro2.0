# LOGIC_ARCH.md
# Архитектура логики 2.0 (Теплица → Зоны → Ноды → Каналы)

Документ описывает **логическую модель системы 2.0** для управления гидропоникой:
какие сущности существуют, кто за что отвечает и как данные проходят по системе.

Цель — дать основу, на которой можно:

- проектировать backend и БД;
- проектировать поведение Python-сервиса и нод ESP32;
- строить UI/UX;
- обучать ИИ-агентов корректно расширять систему, не ломая её.

---

## 1. Базовые сущности и иерархия

### 1.1. Greenhouse (теплица)

- Логический контейнер верхнего уровня.
- Идентификатор: `greenhouses.uid` → сегмент `{gh}` в MQTT.
- Хранит:
 - набор зон;
 - геолокацию/описание;
 - настройки по умолчанию (часовой пояс, язык, системные лимиты).

### 1.2. Zone (зона)

- Основная единица агрономической логики.
- Идентификатор: `zones.uid` → сегмент `{zone}` в MQTT.
- Внутри зоны:
 - работают рецепты (Recipe Engine);
 - действует глобальный план полива, света, климата;
 - назначены узлы и их каналы;
 - считаются агрегированные метрики (средний pH, EC, температура и т.п.).

**Принцип:** все агрономические решения принимаются **на уровне зоны**, а не узла.

### 1.3. DeviceNode (узел ESP32)

- Физическое устройство ESP32/ESP32-S3.
- Идентификатор: `nodes.uid` → сегмент `{node}` в MQTT.
- Узел:
 - не знает про рецепты;
 - не знает про растения;
 - не хранит агрономические цели;
 - реализует только «физику» каналов: измерить / включить / выключить / установить ШИМ и т.п.

### 1.4. Channel (канал узла)

- Логический порт узла: сенсор или актуатор.
- Идентификатор: `channels.key` → сегмент `{channel}` в MQTT.
- Типы:
 - `SENSOR` — pH, EC, температура, влажность, освещённость и т.п.;
 - `ACTUATOR` — насосы, клапаны, освещение, вентиляторы и т.п.;
 - `VIRTUAL` — вычисляемые метрики (например, усреднённый EC по зоне).

Канал **не знает**, зачем его значение нужно системе. Он лишь измеряет/исполняет.

---

## 2. Роли компонентов логики

### 2.1. ESP32-ноды

Роль: **детерминированные исполнительные устройства**.

- Опрос сенсоров → публикация телеметрии в MQTT.
- Выполнение полученных команд (включить насос, изменить ШИМ, начать калибровку и т.д.).
- Локальные safety-механизмы (таймауты, watchdog, защита от зависания реле).
- Никаких долгих расчётов, ML, рецептов, планировщиков.

### 2.2. Python-сервис (MQTT Router + Zone Controllers)

Роль: **логический контроллер зон**.

- Подписка на весь namespace MQTT (`hydro/#`).
- Разбор телеметрии → запись в БД (см. `TELEMETRY_PIPELINE.md`).
- Запуск контроллеров зон:
 - pH-контроллер (поддержание целевого pH);
 - EC-контроллер;
 - климат-контроллер (температура, влажность, CO₂);
 - полив/дренаж;
 - освещение.
- Генерация команд для узлов согласно:
 - активному рецепту;
 - текущим измерениям;
 - ограничениям безопасности.

### 2.3. Backend (Laravel)

Роль: **единственный источник истины по конфигурации и истории**.

- Хранит структуру теплиц/зон/узлов/каналов.
- Хранит рецепты, состояния и расписания.
- Хранит историю телеметрии и событий.
- Предоставляет REST/WS API фронтенду, Android и внешним интеграциям.
- Управляет пользователями, правами доступа, журналированием.

### 2.4. UI (Frontend + Android)

Роль: **визуализация и ручное управление**.

- Отображение текущего состояния зон/узлов.
- Просмотр истории телеметрии, аварий, рецептов.
- Ручное вмешательство: включить/выключить насос, изменить целевой pH, поставить зону на паузу и т.п.
- Настройка рецептов и расписаний.

---

## 3. Логические потоки (сверху вниз)

### 3.1. Конфигурация

1. Пользователь через UI создаёт теплицу/зону/узлы и каналы.
2. Backend сохраняет конфигурацию в PostgreSQL.
3. Python-сервис периодически (или по событию) подтягивает новую конфигурацию:
 - `zones`,
 - `nodes`,
 - `channels`,
 - активные рецепты и их фазы.
4. Python-сервис синхронизирует NodeConfig с узлами:
 - через MQTT-команды и/или REST provisioning (см. `NODE_LIFECYCLE_AND_PROVISIONING.md`).

### 3.2. Телеметрия

1. Узел ESP32 по расписанию опрашивает сенсоры.
2. Публикует сообщения вида:

```text
hydro/{gh}/{zone}/{node}/{channel}/telemetry
```

payload:

```json
{
 "value": 5.78,
 "metric": "PH",
 "ts": 1737355600456
}
```

3. Python-сервис:
 - валидирует payload;
 - записывает в `telemetry_samples` и `telemetry_last`;
 - обновляет состояние контроллера зоны (см. `TELEMETRY_PIPELINE.md`).

4. Backend через БД и/или стримы получает обновления и отдаёт их на UI.

### 3.3. Команды

1. Python-сервис или Backend (через Python API) решает отправить команду узлу.
2. Публикуется сообщение:

```text
hydro/{gh}/{zone}/{node}/{channel}/command
```

payload, например:

```json
{
 "cmd": "SET_PWM",
 "value": 128,
 "ttl_ms": 5000,
 "reason": "ZONE_PH_CORRECTION",
 "request_id": "cmd-2025-01-01-12-00-00-001"
}
```

3. Узел ESP32:
 - читает команду;
 - проверяет TTL/валидность;
 - выполняет действие;
 - публикует `status`/`event` с результатом:

```text
hydro/{gh}/{zone}/{node}/{channel}/status
```

```json
{
 "request_id": "cmd-2025-01-01-12-00-00-001",
 "status": "OK",
 "ts": 1737355601123
}
```

---

## 4. Взаимодействие с рецептами (Recipe Engine)

1. Zone имеет активный рецепт (`recipes` + `recipe_phases`). 
2. Для каждой фазы заданы:
 - цели pH, EC, температуры, влажности, освещения;
 - ограничения по скоростям изменения;
 - расписания полива/дренажа/света.
3. Python-контроллер зоны считывает текущую фазу и цели.
4. На основании телеметрии формирует команды узлам (через MQTT).

Принцип: **рецепты и фазы никогда не хранятся в узлах** — только в БД (через backend).

---

## 5. Ошибки, аварии и безопасные режимы

- Узлы публикуют события:

```text
hydro/{gh}/{zone}/{node}/{channel}/event
```

payload (пример):

```json
{
 "type": "SENSOR_ERROR",
 "code": "PH_PROBE_DISCONNECTED",
 "ts": 1737355600456
}
```

- Python-сервис:
 - сохраняет событие в БД (`events`, `alerts`);
 - в зависимости от типа может перевести зону в безопасный режим (например, отключить дозаторы).

- Backend:
 - показывает алерты в UI;
 - может отправлять уведомления (Telegram, email и т.п.).

---

## 6. Принципы для ИИ-агентов

1. **Не переносить бизнес-логику в ESP32.** 
 Любые изменения в логике pH/EC/климата — только в Python/Backend.

2. **Не ломать MQTT namespace.** 
 Любые новые топики должны соответствовать правилам `MQTT_NAMESPACE.md`.

3. **Сначала модель данных → потом код.** 
 При добавлении новой сущности:
 - прописать её в `DATA_MODEL_REFERENCE.md`;
 - добавить миграции;
 - только потом менять Python/ESP32.

4. **Не усложнять схемы команд.** 
 Команды должны быть простыми, детерминированными и проверяемыми.

5. **Единая точка истины.** 
 Любые настройки/рецепты/пользовательские решения должны храниться в БД, а не в конфиг-файлах ESP32.

---

## 7. Краткое резюме логики 2.0

- Теплица → Зоны → Узлы → Каналы — основная иерархия.
- ESP32 — минимальные исполнительные устройства без бизнес-логики.
- Python-сервис — главный логический контроллер зон и маршрутизатор MQTT↔БД.
- Backend — конфигурация, история, пользователи, API.
- UI/Android — визуализация и ручное управление.
- Все решения по pH/EC/климату/поливу принимаются **в зоне**, а не в узле.
