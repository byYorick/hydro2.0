# DEV_CONVENTIONS.md
# Конвенции разработки для проекта Hydro 2.0

Этот документ описывает единые правила разработки для всех участников и ИИ‑агентов,
работающих над проектом Hydro 2.0. Цель — чтобы любой человек или агент мог продолжить
работу с минимальным количеством вопросов и конфликтов в коде/структуре.

---

## 1. Общие принципы

1. **Single Source of Truth**  
   - Архитектурная истина — в файлах `SYSTEM_ARCH_FULL.md` и документах из каталога `01_SYSTEM`.  
   - Для прошивок — спецификации из `02_HARDWARE_FIRMWARE`.  
   - Для транспорта — `03_TRANSPORT_MQTT`.  
   - Для бэкенда — `04_BACKEND_CORE`.  
   - Для доменной логики/рецептов — `06_DOMAIN_ZONES_RECIPES`.  
   - Для ИИ и цифрового двойника — `09_AI_AND_DIGITAL_TWIN` и `10_AI_DEV_GUIDES`.

2. **Документ → Интерфейс → Реализация**  
   - Сначала обновляется/создаётся спецификация (Markdown).  
   - Затем описывается интерфейс (заголовочные файлы, API‑контракты, схемы MQTT).  
   - Только после этого пишется реализация.

3. **Без “магии”**  
   - Любое нестандартное решение кратко описывается: либо в комментарии в коде,
     либо в соответствующем Markdown‑файле раздела `Rationale`.

4. **Совместимость с ИИ‑агентами**  
   - Код и документация должны быть понятны моделям: логичные имена, предсказуемая структура,
     чёткие комментарии.  
   - Для сложных задач всегда создаётся отдельный `.md` с постановкой и контекстом
     (см. `TASKS_FOR_AI_AGENTS.md`).

---

## 2. Структура репозитория и папок

- Корень репозитория содержит:
  - Общие спецификации и правила (`SYSTEM_ARCH_FULL.md`, `DEV_CONVENTIONS.md`, `TASKS_FOR_AI_AGENTS.md` и др.).
  - Каталоги `01_…`–`12_…`, группирующие артефакты по слоям системы.

- **Запрещено**:
  - Создавать новые “версии” архитектуры в виде папок `v3`, `v4` и т.п.  
    Hydro 2.0 — одна живая версия, эволюция фиксируется в Git.

- При добавлении новых файлов:
  - Файл должен логически попадать в одну из существующих папок.  
  - Если логичного места нет — сначала обновляется архитектурный документ,
    где обосновывается новая структура, и только потом создаётся папка/файл.

---

## 3. Git‑флоу и ветки

1. **Основные ветки**
   - `main` — стабильная, всегда собираемая и развертываемая версия.  
   - `dev` (по желанию) — интеграционная ветка, куда мёржатся фичи перед попаданием в `main`.

2. **Feature‑ветки**
   - Имя ветки: `feature/<кратко_о_задаче>`  
     Примеры:  
     - `feature/oled-menu-navigation`  
     - `feature/mqtt-backend-auth`  
     - `feature/android-wifi-provisioning`

3. **Коммиты**
   - Формат сообщения:  
     `тип: краткое описание`  
     Где `тип` один из:
     - `feat` — новая функциональность
     - `fix` — исправление бага
     - `refactor` — рефакторинг без изменения поведения
     - `docs` — только документация
     - `test` — тесты
     - `chore` — сервисные изменения (скрипты, конфиги CI и пр.)

   - Примеры сообщений:
     - `feat: add mqtt telemetry encoder for ph node`
     - `fix: correct i2c bus init for ec node`
     - `docs: expand ai agent task templates`

4. **Pull Request / Merge Request**
   - В описании PR обязательно:
     - Ссылка на задачу/документ спецификации.
     - Короткое резюме изменений.
     - Список потенциально затронутых модулей.

---

## 4. Конвенции для прошивок (ESP32, C, ESP‑IDF)

1. **Язык и стандарт**
   - Язык: C с ESP‑IDF.  
   - Цель — совместимость с актуальной LTS‑версией ESP‑IDF, без использования неустойчивых,
     эксперементальных API без необходимости.

2. **Структура прошивки**
   - Общие принципы и дерево каталогов описаны в `02_HARDWARE_FIRMWARE/FIRMWARE_STRUCTURE.md`.  
   - Для каждой ноды:
     - Отдельный каталог с именем ноды (например, `node_ph`, `node_ec`, `node_climate`).  
     - Внутри — разделение на:
       - `main` (точка входа, high‑level логика)
       - `drivers` (работа с датчиками, железом)
       - `ui` (OLED/экран)
       - `net` (Wi‑Fi, MQTT)
       - `config` (настройки, `sdkconfig.defaults`)

3. **Именование**
   - Файлы:
     - Заголовочные: `snake_case.h`
     - Исходники: `snake_case.c`
   - Функции и переменные: `snake_case`
   - Типы и enum: `PascalCase` (например, `PhNodeState`, `MeasurementResult`)
   - Макросы и константы: `UPPER_SNAKE_CASE`

4. **Логика модулей**
   - Каждый модуль должен иметь чётко очерченную ответственность. Примеры:
     - `ph_sensor_driver.c` — только чтение/калибровка pH‑датчика.
     - `oled_screen_ph.c` — отрисовка UI для pH‑ноды.
     - `mqtt_client_node_common.c` — общий код MQTT‑клиента для всех нод.
   - Запрещено смешивать:
     - доступ к железу и сложную бизнес‑логику в одном файле;
     - UI и прямой доступ к сетевым/датчиковым драйверам.

5. **Обработка ошибок**
   - Все функции, вызывающие ESP‑IDF API, должны обрабатывать возвращаемые коды.  
   - Для повторяющихся проверок используем вспомогательные макросы/функции
     (например, `CHECK_ESP_ERROR`, `RETURN_ON_FAIL`).
   - Любая критическая ошибка логируется через `ESP_LOGE` с максимально понятным контекстом.

6. **Логи**
   - Используем стандартные теги вида:  
     - `"PH_NODE"`, `"EC_NODE"`, `"OLED_UI"`, `"MQTT_CLIENT"`.  
   - Логи не должны превращаться в “мусорную свалку”:
     - В рабочем режиме предусмотреть уровни логирования (`INFO`/`WARN`/`ERROR`).  
     - В дебаг‑режиме можно включать `DEBUG`, но осознанно.

7. **Конфигурация (`sdkconfig` и т.п.)**
   - Базовые значения — в `sdkconfig.defaults` в каталоге ноды.  
   - Все важные параметры должны иметь описания в соответствующем `.md`‑файле,
     чтобы ИИ‑агент понимал их смысл.

---

## 5. Конвенции для бэкенда и сервисов

В проекте допускается несколько реализаций бэкенда (например, на Python/FastAPI или Node.js/NestJS),
но для конкретного развёртывания используется строго одна выбранная связка. Общие правила:

1. **Организация кода**
   - Чёткое разделение слоёв:
     - транспортный слой (REST / WebSocket / MQTT‑bridge)
     - слой бизнес‑логики (зоны, рецепты, контроль параметров)
     - слой доступа к данным (БД, кэш, файловое хранилище).

2. **API‑контракты**
   - Описываются в `04_BACKEND_CORE/API_SPEC_FRONTEND_BACKEND_FULL.md`
     и `04_BACKEND_CORE/REST_API_REFERENCE.md`.
   - Любое изменение API сначала фиксируется в документации,
     затем реализуется в коде.

3. **Создание новых сервисов**
   - Нельзя плодить микросервисы без обоснования.
   - Любой новый сервис должен быть:
     - описан в архитектуре,
     - привязан к конкретному доменному сценарию,
     - обеспечен минимальной наблюдаемостью (логи, метрики).

---

## 6. Конвенции по документации (Markdown)

1. **Язык**
   - Основной язык документов — русский.  
   - Английские термины используются там, где так проще и привычнее для разработчиков
     (например, `node`, `backend`, `firmware`, `MQTT topic`).

2. **Структура документа**
   - Стандартные разделы:
     - `Цель`
     - `Контекст`
     - `Требования`
     - `Архитектура / Дизайн`
     - `Протоколы / Интерфейсы`
     - `Сценарии использования`
     - `Ограничения и риски`
     - `Планы развития`

3. **Версионирование**
   - Версионность фиксируется в заголовке документа (`Версия`, `Дата`, `Автор`),
     но не дублируется в названии файла.

4. **Связи между документами**
   - В начале файла рекомендуется перечислить связанные документы (раздел `Связанные документы`)
     со ссылками на них.

---

## 7. Работа с ИИ‑агентами

- Все правила постановки задач ИИ подробно описаны в `TASKS_FOR_AI_AGENTS.md`.  
- Здесь фиксируются только базовые принципы:
  1. Любая нетривиальная задача должна иметь **отдельный `.md`‑файл с формализованным запросом**.
  2. Внутри задач не используются “магические” формулировки — всё максимально конкретно:
     файлы, функции, структуры данных, форматы сообщений.
  3. Результат работы ИИ проверяется человеком или другим ИИ‑агентом,
     настроенным на ревью/валидацию.

---

## 8. Тестирование

1. **Прошивки**
   - Минимум:
     - юнит‑тесты для критичных алгоритмов;
     - протокол ручного тестирования нод в стенде (описанный в `.md`‑файлах).

2. **Бэкенд**
   - Юнит‑тесты для бизнес‑логики.  
   - Интеграционные тесты для ключевых API‑эндпоинтов.

3. **Автоматизация**
   - Цель — со временем вынести сборку, базовые тесты и проверки стиля в CI,
     со скриптами и конфигурацией, описанными в отдельном каталоге (например, `ci/`).

---

## 9. Расширение конвенций

- Любое расширение/изменение этих правил происходит через:
  1. Обновление этого документа с описанием мотивации.
  2. Обсуждение и фиксацию в системе управления задачами.
  3. Применение в новых коммитах/PR.

Этот файл должен рассматриваться как “живая конституция” проекта:  
если в каком‑то месте конвенции не совпадают с текущей реализацией,  
это повод либо обновить код, либо пересмотреть правила и честно их переписать.
