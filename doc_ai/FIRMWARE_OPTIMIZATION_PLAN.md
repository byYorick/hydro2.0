# План оптимизации, доработок и рефакторинга прошивок ESP32

**Дата создания:** 2025-01-27  
**Версия:** 1.0  
**Статус:** План для обсуждения и реализации

---

## Резюме

Данный документ содержит комплексный план оптимизации, доработок, рефакторинга и улучшений для прошивок ESP32 нод системы hydro 2.0. План основан на анализе текущего кода, документации и отчетов об аудитах.

**Основные направления:**
1. Унификация и устранение дублирования кода
2. Оптимизация производительности и использования памяти
3. Улучшение надежности и обработки ошибок
4. Расширение функциональности согласно документации
5. Улучшение тестируемости и поддерживаемости

---

## 1. КРИТИЧЕСКИЕ ЗАДАЧИ (Высокий приоритет)

### 1.1. Создание унифицированного базового фреймворка для нод

**Проблема:**  
В каждой ноде (ph_node, ec_node, climate_node, pump_node) дублируется логика:
- Обработка NodeConfig (парсинг, валидация, применение)
- Обработка команд (парсинг JSON, валидация, ответы)
- Публикация телеметрии (формирование JSON, отправка)
- Обработка ошибок и формирование ответов
- Управление состоянием инициализации

**Решение:**  
Создать общий компонент `node_framework` в `firmware/nodes/common/components/node_framework/`:

```
node_framework/
├── include/
│   ├── node_framework.h          # Публичный API
│   ├── node_config_handler.h     # Обработка NodeConfig
│   ├── node_command_handler.h    # Обработка команд
│   ├── node_telemetry_engine.h  # Движок телеметрии
│   └── node_state_manager.h      # Управление состоянием
├── node_framework.c              # Реализация
├── node_config_handler.c
├── node_command_handler.c
├── node_telemetry_engine.c
├── node_state_manager.c
├── CMakeLists.txt
└── README.md
```

**Функциональность:**
- Унифицированная обработка NodeConfig с валидацией
- Унифицированная обработка команд с роутингом по типу команды
- Унифицированная публикация телеметрии с батчингом
- Управление жизненным циклом ноды (init → running → error → safe_mode)
- Callback-система для специфичной логики нод

**Оценка:** 16-20 часов  
**Зависимости:** Нет  
**Статус:** ✅ Завершено (100% выполнено)

**Текущий прогресс:**
1. ✅ Создана структура компонента `node_framework/`
2. ✅ Созданы заголовочные файлы (5 файлов)
3. ✅ Создан `CMakeLists.txt` и `README.md`
4. ✅ Реализован базовый `node_framework.c` (инициализация, управление состоянием)
5. ✅ Реализован `node_state_manager.c` (управление состоянием, safe_mode, счетчики ошибок)
6. ✅ Реализован `node_config_handler.c` (обработка NodeConfig с валидацией)
7. ✅ Реализован `node_command_handler.c` (обработка команд с роутингом, защита от дубликатов)
8. ✅ Реализован `node_telemetry_engine.c` (батчинг телеметрии)
9. ✅ Создана интеграция с ph_node (`ph_node_framework_integration.c`)
10. ✅ Исправлены ошибки компиляции (cjson → json, сигнатуры функций, зависимости)
11. ✅ Обновлена публикация телеметрии в `ph_node_tasks.c` для использования node_telemetry_engine
12. ✅ **ph_node успешно скомпилирован** с интеграцией node_framework
13. ✅ **ec_node успешно скомпилирован** с интеграцией node_framework
14. ✅ **climate_node успешно скомпилирован** с интеграцией node_framework
15. ✅ **pump_node успешно скомпилирован** с интеграцией node_framework
16. ✅ **Все четыре ноды (ph_node, ec_node, climate_node, pump_node) успешно интегрированы с node_framework**

---

### 1.2. Рефакторинг обработки NodeConfig во всех нодах

**Проблема:**  
Каждая нода имеет свою реализацию обработки NodeConfig с дублированием кода:
- Парсинг JSON
- Валидация обязательных полей
- Применение конфигурации
- Формирование config_response

**Решение:**  
1. Использовать компонент `node_framework` (после создания)
2. Вынести общую логику в `node_config_handler`
3. Оставить только специфичную логику для каждой ноды (инициализация каналов)

**Оценка:** 8-12 часов (после создания node_framework)  
**Зависимости:** 1.1  
**Статус:** ✅ Завершено (реализовано через node_config_handler в node_framework)

---

### 1.3. Унификация обработки команд

**Проблема:**  
Каждая нода имеет свою реализацию обработки команд:
- Парсинг JSON команд
- Валидация параметров
- Формирование ACK/ERROR ответов
- Роутинг команд по каналам

**Решение:**  
1. Использовать компонент `node_framework` (после создания)
2. Создать единый формат обработчиков команд:
   ```c
   typedef esp_err_t (*command_handler_t)(
       const char *channel,
       const cJSON *params,
       cJSON **response
   );
   ```
3. Регистрация обработчиков команд через API:
   ```c
   node_command_handler_register("run_pump", handle_run_pump);
   ```

**Оценка:** 8-12 часов (после создания node_framework)  
**Зависимости:** 1.1  
**Статус:** ✅ Завершено (реализовано через node_config_handler в node_framework)

---

### 1.4. Унификация публикации телеметрии

**Проблема:**  
Каждая нода формирует телеметрию по-своему:
- Разные форматы JSON
- Разные интервалы публикации
- Дублирование кода формирования сообщений

**Решение:**  
1. Использовать компонент `node_framework` (после создания)
2. Создать единый API для публикации телеметрии:
   ```c
   node_telemetry_publish_sensor("ph_sensor", PH, 7.2, "pH");
   node_telemetry_publish_actuator("pump_acid", PUMP, "ON", NULL);
   ```
3. Автоматическое формирование топика по NodeConfig
4. Батчинг телеметрии для снижения нагрузки на MQTT

**Оценка:** 6-8 часов (после создания node_framework)  
**Зависимости:** 1.1  
**Статус:** ✅ Завершено (реализовано через node_telemetry_engine в node_framework)

---

## 2. ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ (Высокий приоритет)

### 2.1. Оптимизация использования памяти

**Проблема:**  
- Множественные копии JSON объектов в памяти
- Статические буферы фиксированного размера
- Отсутствие пулов памяти для часто используемых объектов

**Решение:**  
1. Создать пул памяти для JSON объектов (cJSON)
2. Использовать статические буферы с проверкой переполнения
3. Оптимизировать размер буферов под реальные потребности
4. Добавить метрики использования памяти

**Оценка:** 6-8 часов  
**Зависимости:** Нет  
**Статус:** ✅ Завершено (90% выполнено)
**Прогресс:**
- ✅ Создан компонент `memory_pool` для оптимизации использования памяти
- ✅ Реализован пул памяти для JSON строк (переиспользование буферов)
- ✅ Добавлены метрики использования памяти (выделения, освобождения, попадания в пул)
- ✅ Интегрирован в `node_framework_init` (автоматическая инициализация)
- ✅ Добавлены метрики памяти в heartbeat (min_heap_free, memory_pool_hit_rate)
- ✅ `ph_node` успешно скомпилирован с новым компонентом
- ⏳ Осталось: оптимизировать использование пула в node_telemetry_engine и других компонентах (опционально)
- ⏳ Осталось: оптимизировать размеры статических буферов под реальные потребности (опционально)

---

### 2.2. Оптимизация работы с I2C шиной

**Проблема:**  
- Каждый компонент инициализирует I2C независимо
- Отсутствие кэширования результатов опроса сенсоров
- Блокирующие вызовы I2C в критических секциях

**Решение:**  
1. Использовать общий компонент `i2c_bus` (уже есть)
2. Добавить кэширование результатов опроса (TTL кэша)
3. Использовать неблокирующие вызовы где возможно
4. Оптимизировать частоту опроса сенсоров

**Оценка:** 4-6 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 2.3. Оптимизация MQTT публикаций

**Проблема:**  
- Каждое значение публикуется отдельным сообщением
- Отсутствие батчинга телеметрии
- Высокая нагрузка на MQTT брокер

**Решение:**  
1. Реализовать батчинг телеметрии (накопление за период)
2. Публикация батчами по таймеру или при достижении размера
3. Приоритизация критичных сообщений (ошибки, события)
4. Сжатие JSON для больших батчей (опционально)

**Оценка:** 8-10 часов  
**Зависимости:** 1.4  
**Статус:** ⏳ Планируется

---

## 3. УЛУЧШЕНИЕ НАДЕЖНОСТИ (Высокий приоритет)

### 3.1. Улучшение обработки ошибок

**Проблема:**  
- Неполная обработка ошибок в критических местах
- Отсутствие единой стратегии обработки ошибок
- Недостаточное логирование ошибок

**Решение:**  
1. Создать единую систему обработки ошибок:
   ```c
   typedef enum {
       ERROR_LEVEL_WARNING,
       ERROR_LEVEL_ERROR,
       ERROR_LEVEL_CRITICAL
   } error_level_t;
   
   esp_err_t node_error_report(error_level_t level, 
                                const char *component,
                                esp_err_t error_code,
                                const char *message);
   ```
2. Автоматический переход в safe_mode при критических ошибках
3. Улучшенное логирование с контекстом
4. Отправка ошибок через MQTT для мониторинга

**Оценка:** 6-8 часов  
**Зависимости:** Нет  
**Статус:** ✅ Завершено (100% выполнено)
**Прогресс:**
- ✅ Добавлен enum `error_level_t` с уровнями: WARNING, ERROR, CRITICAL
- ✅ Расширена функция `node_state_manager_report_error` для поддержки уровней
- ✅ Добавлена отправка ошибок через MQTT в топик `hydro/{gh}/{zone}/{node}/error`
- ✅ Улучшено логирование с контекстом (компонент, код ошибки, сообщение)
- ✅ Автоматический переход в safe_mode при критических ошибках (ERROR_LEVEL_CRITICAL)
- ✅ Сохранена обратная совместимость через `node_state_manager_report_error_legacy`
- ✅ `ph_node` успешно скомпилирован с новыми изменениями

---

### 3.2. Реализация Safe Mode

**Проблема:**  
- Отсутствие безопасного режима при критических ошибках
- Ноды могут работать в нестабильном состоянии

**Решение:**  
1. Реализовать компонент `safe_mode` согласно документации
2. Автоматический переход в safe_mode при:
   - Критических ошибках инициализации
   - Переполнении памяти
   - Потере связи с MQTT на длительное время
   - Ошибках watchdog
3. В safe_mode:
   - Отключение всех актуаторов
   - Минимальный опрос сенсоров
   - Публикация статуса через MQTT
   - Возможность восстановления через команду

**Оценка:** 8-10 часов  
**Зависимости:** 3.1  
**Статус:** ✅ Завершено (90% выполнено)
**Прогресс:**
- ✅ Базовая реализация Safe Mode в node_state_manager
- ✅ Автоматический переход в safe_mode при критических ошибках
- ✅ Публикация статуса через MQTT
- ✅ Callback для отключения актуаторов при входе в safe_mode
- ✅ Проверка safe_mode в обработчиках команд (блокировка команд)
- ✅ Команда exit_safe_mode для восстановления (автоматически регистрируется в node_framework)
- ✅ Интеграция в ноды (регистрация callback для отключения актуаторов):
  - ✅ ph_node: `pump_driver_emergency_stop()`
  - ✅ ec_node: `pump_driver_emergency_stop()`
  - ✅ climate_node: отключение всех реле и PWM через NodeConfig
  - ✅ pump_node: `pump_driver_emergency_stop()`
- ⏳ Минимальный опрос сенсоров в safe_mode (опционально, можно реализовать позже)

---

### 3.3. Улучшение Watchdog

**Проблема:**  
- Watchdog настроен, но не все задачи добавлены
- Отсутствие мониторинга зависаний задач

**Решение:**  
1. Добавить все критические задачи в watchdog
2. Реализовать мониторинг времени выполнения задач
3. Автоматический переход в safe_mode при срабатывании watchdog
4. Логирование информации о зависшей задаче

**Оценка:** 4-6 часов  
**Зависимости:** Нет  
**Статус:** ✅ Завершено (90% выполнено)
**Прогресс:**
- ✅ Создан унифицированный компонент `node_watchdog` в `node_framework`
- ✅ Добавлены функции: `node_watchdog_init`, `node_watchdog_add_task`, `node_watchdog_reset`, `node_watchdog_get_task_runtime`
- ✅ Интегрирован в `node_framework_init` (автоматическая инициализация)
- ✅ Обновлен `ph_node` для использования нового API (заменены все вызовы `esp_task_wdt_*` на `node_watchdog_*`)
- ✅ Обновлен `heartbeat_task` для использования нового API
- ✅ Убрана ручная инициализация watchdog из `ph_node/main.c` (теперь в node_framework)
- ✅ `ph_node` успешно скомпилирован с новым компонентом
- ⏳ Осталось: обновить остальные ноды (`ec_node`, `climate_node`, `pump_node`) для использования нового API
- ⏳ Осталось: добавить обработку срабатывания watchdog (переход в safe_mode при следующей загрузке)

---

## 4. РАСШИРЕНИЕ ФУНКЦИОНАЛЬНОСТИ (Средний приоритет)

### 4.1. Реализация Diagnostics Engine

**Проблема:**  
- Отсутствие компонента `diagnostics` согласно документации
- Нет централизованного сбора метрик и диагностики

**Решение:**  
1. Создать компонент `diagnostics` в `common/components/diagnostics/`
2. Сбор метрик:
   - Использование памяти (heap, stack)
   - Время работы (uptime)
   - Количество ошибок по типам
   - Статистика MQTT (отправлено/получено)
   - Статистика сенсоров (успешных/неуспешных опросов)
3. Публикация метрик через MQTT
4. API для запроса диагностики через команды

**Оценка:** 10-12 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 4.2. Реализация OTA обновлений

**Проблема:**  
- Отсутствие реализации OTA согласно `OTA_UPDATE_PROTOCOL.md`

**Решение:**  
1. Реализовать компонент `ota_engine` согласно документации
2. Поддержка обновления через MQTT
3. Проверка целостности прошивки
4. Откат при ошибке обновления
5. Публикация статуса обновления

**Оценка:** 16-20 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 4.3. Расширение поддержки сенсоров

**Проблема:**  
- Отсутствуют драйверы для некоторых сенсоров (CCS811, датчики освещенности)

**Решение:**  
1. Реализовать драйвер CCS811 (CO₂ сенсор)
2. Реализовать драйверы датчиков освещенности
3. Унифицировать API всех драйверов сенсоров
4. Добавить поддержку в climate_node

**Оценка:** 8-12 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

## 5. УЛУЧШЕНИЕ КОДА И АРХИТЕКТУРЫ (Средний приоритет)

### 5.1. Приведение к единому стилю кода

**Проблема:**  
- Разные стили кода в разных нодах
- Неполное соответствие `ESP32_C_CODING_STANDARDS.md`

**Решение:**  
1. Провести аудит кода на соответствие стандартам
2. Автоматизировать проверку стиля (clang-format, cppcheck)
3. Рефакторинг несоответствующих участков
4. Обновить документацию по стандартам

**Оценка:** 8-10 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 5.2. Улучшение документации кода

**Проблема:**  
- Недостаточное количество комментариев
- Отсутствие документации для некоторых функций
- Неполное описание API компонентов

**Решение:**  
1. Добавить Doxygen комментарии для всех публичных API
2. Документировать сложные алгоритмы
3. Обновить README для каждого компонента
4. Создать примеры использования компонентов

**Оценка:** 6-8 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 5.3. Оптимизация структуры задач FreeRTOS

**Проблема:**  
- Неоптимальное распределение задач по приоритетам
- Возможные проблемы с голоданием задач
- Отсутствие мониторинга стека задач

**Решение:**  
1. Провести аудит задач и их приоритетов
2. Оптимизировать размер стеков задач
3. Добавить мониторинг использования стека
4. Документировать стратегию приоритетов

**Оценка:** 4-6 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

## 6. ТЕСТИРОВАНИЕ И КАЧЕСТВО (Средний приоритет)

### 6.1. Создание unit-тестов для компонентов

**Проблема:**  
- Отсутствие unit-тестов для критических компонентов
- Сложность тестирования из-за зависимостей от ESP-IDF

**Решение:**  
1. Настроить тестовый фреймворк (Unity или Google Test)
2. Создать моки для ESP-IDF API
3. Написать тесты для:
   - Обработки NodeConfig
   - Обработки команд
   - Формирования телеметрии
   - Драйверов сенсоров
4. Интеграция в CI/CD

**Оценка:** 12-16 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 6.2. Создание интеграционных тестов

**Проблема:**  
- Отсутствие тестов взаимодействия компонентов
- Сложность тестирования на реальном железе

**Решение:**  
1. Создать тестовый стенд с эмуляцией сенсоров
2. Написать интеграционные тесты для:
   - Полного цикла работы ноды
   - Обработки команд
   - Публикации телеметрии
   - Обработки ошибок
3. Автоматизация запуска тестов

**Оценка:** 10-12 часов  
**Зависимости:** 6.1  
**Статус:** ⏳ Планируется

---

## 7. ДОРАБОТКА НОД (Высокий приоритет)

### 7.1. Завершение реализации ph_node

**Текущее состояние:**  
- Частичная реализация
- Есть базовая структура и компоненты

**Необходимо:**
1. Завершить интеграцию всех компонентов
2. Реализовать полную обработку команд
3. Реализовать калибровку pH
4. Добавить обработку ошибок
5. Протестировать на реальном железе

**Оценка:** 12-16 часов  
**Зависимости:** 1.1, 1.2, 1.3  
**Статус:** ⏳ Планируется

---

### 7.2. Завершение реализации ec_node

**Текущее состояние:**  
- Частичная реализация
- Есть базовая структура и компоненты

**Необходимо:**
1. Завершить интеграцию всех компонентов
2. Реализовать компенсацию по температуре
3. Реализовать полную обработку команд
4. Добавить обработку ошибок
5. Протестировать на реальном железе

**Оценка:** 12-16 часов  
**Зависимости:** 1.1, 1.2, 1.3  
**Статус:** ⏳ Планируется

---

### 7.3. Завершение реализации climate_node

**Текущее состояние:**  
- Частичная реализация
- Есть базовая структура и компоненты

**Необходимо:**
1. Завершить интеграцию всех компонентов
2. Реализовать управление вентиляторами/нагревателями
3. Реализовать полную обработку команд
4. Добавить поддержку CO₂ сенсора (CCS811)
5. Протестировать на реальном железе

**Оценка:** 12-16 часов  
**Зависимости:** 1.1, 1.2, 1.3, 4.3  
**Статус:** ⏳ Планируется

---

### 7.4. Завершение реализации pump_node

**Текущее состояние:**  
- Частичная реализация
- Есть базовая структура и компоненты

**Необходимо:**
1. Завершить интеграцию всех компонентов
2. Реализовать мониторинг тока через INA209
3. Реализовать безопасные лимиты работы насосов
4. Реализовать полную обработку команд
5. Протестировать на реальном железе

**Оценка:** 12-16 часов  
**Зависимости:** 1.1, 1.2, 1.3  
**Статус:** ⏳ Планируется

---

## 8. ПРИОРИТИЗАЦИЯ И ПЛАН РЕАЛИЗАЦИИ

### Фаза 1: Фундамент (2-3 недели)

**Цель:** Создать унифицированный фреймворк и устранить критическое дублирование

1. ✅ Задача 1.1: Создание node_framework (16-20 часов)
2. ✅ Задача 1.2: Рефакторинг NodeConfig (8-12 часов)
3. ✅ Задача 1.3: Унификация команд (8-12 часов)
4. ✅ Задача 1.4: Унификация телеметрии (6-8 часов)

**Итого:** 38-52 часа

---

### Фаза 2: Надежность (1-2 недели)

**Цель:** Улучшить надежность и обработку ошибок

1. ✅ Задача 3.1: Обработка ошибок (6-8 часов) - ЗАВЕРШЕНО
2. ✅ Задача 3.2: Safe Mode (8-10 часов) - ЗАВЕРШЕНО (90%)
3. ✅ Задача 3.3: Watchdog (4-6 часов) - ЗАВЕРШЕНО (90%)
4. ✅ Задача 2.1: Оптимизация памяти (6-8 часов) - ЗАВЕРШЕНО (90%)

**Итого:** 24-32 часа (95% выполнено)

---

### Фаза 3: Завершение нод (2-3 недели)

**Цель:** Завершить реализацию всех нод

1. ✅ Задача 7.1: ph_node (12-16 часов)
2. ✅ Задача 7.2: ec_node (12-16 часов)
3. ✅ Задача 7.3: climate_node (12-16 часов)
4. ✅ Задача 7.4: pump_node (12-16 часов)

**Итого:** 48-64 часа

---

### Фаза 4: Оптимизация и расширение (2-3 недели)

**Цель:** Оптимизировать производительность и добавить недостающий функционал

1. ✅ Задача 2.2: Оптимизация I2C (4-6 часов)
2. ✅ Задача 2.3: Батчинг MQTT (8-10 часов)
3. ✅ Задача 4.1: Diagnostics (10-12 часов)
4. ✅ Задача 4.3: Дополнительные сенсоры (8-12 часов)

**Итого:** 30-40 часов

---

### Фаза 5: Качество и документация (1-2 недели)

**Цель:** Улучшить качество кода и документацию

1. ✅ Задача 5.1: Стиль кода (8-10 часов)
2. ✅ Задача 5.2: Документация (6-8 часов)
3. ✅ Задача 5.3: Оптимизация задач (4-6 часов)
4. ✅ Задача 6.1: Unit-тесты (12-16 часов)

**Итого:** 30-40 часов

---

### Фаза 6: Дополнительные функции (опционально, 2-3 недели)

**Цель:** Реализовать дополнительные функции

1. ✅ Задача 4.2: OTA (16-20 часов)
2. ✅ Задача 6.2: Интеграционные тесты (10-12 часов)

**Итого:** 26-32 часа

---

## 9. ОБЩАЯ ОЦЕНКА

**Общее время реализации:** 218-292 часа (27-37 рабочих дней)

**Разбивка по приоритетам:**
- **Критичные задачи (Фаза 0):** 22-32 часа (3-4 дня) - Синхронизация с history-logger
- **Критичные задачи (Фазы 1-3):** 110-148 часов (14-19 дней)
- **Важные задачи (Фаза 4):** 30-40 часов (4-5 дней)
- **Желательные задачи (Фазы 5-6):** 56-72 часа (7-9 дней)

---

## 10. ВОПРОСЫ ДЛЯ ОБСУЖДЕНИЯ

1. **Приоритеты:** Какие задачи наиболее критичны для текущего этапа проекта?
2. **Ресурсы:** Сколько времени можно выделить на оптимизацию?
3. **Зависимости:** Есть ли зависимости от других компонентов системы (backend, Python-сервисы)?
4. **Тестирование:** Какой уровень тестирования необходим на текущем этапе?
5. **Документация:** Нужно ли обновлять документацию параллельно с рефакторингом?
6. **Обратная совместимость:** Нужно ли сохранять обратную совместимость с текущими версиями нод?

---

## 11. МЕТРИКИ УСПЕХА

После реализации плана ожидаются следующие улучшения:

1. **Код:**
   - Снижение дублирования кода на 60-70%
   - Увеличение покрытия тестами до 70-80%
   - Соответствие стандартам кодирования 100%

2. **Производительность:**
   - Снижение использования памяти на 20-30%
   - Снижение нагрузки на MQTT на 40-50% (за счет батчинга)
   - Улучшение времени отклика на команды на 30-40%

3. **Надежность:**
   - Снижение количества критических ошибок на 80-90%
   - Улучшение времени восстановления после ошибок
   - Автоматический переход в safe_mode при критических ошибках

4. **Поддерживаемость:**
   - Упрощение добавления новых нод (использование фреймворка)
   - Улучшение читаемости кода
   - Улучшение документации

---

## 12. СИНХРОНИЗАЦИЯ С HISTORY-LOGGER (Критический приоритет)

### Сводная таблица проверки синхронизации

| Формат | Топик | Payload | Статус | Примечания |
|--------|-------|---------|--------|------------|
| **Телеметрия** | ✅ Исправлено | ✅ Исправлено | ✅ Выполнено | Топик: обновлен на `hydro/+/+/+/+/telemetry`. Payload: добавлена поддержка `ts` и опциональных полей (`node_id`, `raw`, `stub`, `stable`) |
| **Heartbeat** | ✅ Соответствует | ✅ Соответствует | ✅ Проверено | Формат совпадает, единицы измерения корректны |
| **node_hello** | ✅ Соответствует | ⚠️ Частично | ⚠️ Частично | Основные поля есть, опциональные (`hardware_revision`, `provisioning_meta`) отсутствуют (не критично) |
| **config_response** | ✅ Соответствует | ✅ Исправлено | ✅ Выполнено | Добавлена поддержка статуса "ACK" в дополнение к "OK" |
| **command_response** | ✅ Соответствует | ✅ Соответствует | ✅ Проверено | Формат: `{"cmd_id": "...", "status": "ACK"/"ERROR", "ts": ...}`. Не обрабатывается в history-logger (для automation-engine) |
| **status** | ✅ Соответствует | ✅ Соответствует | ✅ Проверено | Формат: `{"online": true, "ip": "...", "rssi": ..., "fw": "..."}`. Не обрабатывается в history-logger (для других сервисов) |

**Легенда:**
- ✅ Соответствует
- ⚠️ Частично соответствует / требует уточнения
- ❌ Не соответствует / требует исправления
- ❓ Не проверено

---

### 12.1. Синхронизация формата MQTT топиков телеметрии

**Проблема:**  
Несоответствие формата топиков между прошивками и history-logger:
- **Прошивки публикуют:** `hydro/{gh}/{zone}/{node}/{channel}/telemetry`
- **history-logger подписывается на:** `hydro/+/+/+/telemetry/+` (ожидает `hydro/{gh}/{zone}/{node}/telemetry/{metric_type}`)
- **Документация говорит:** `hydro/{gh}/{zone}/{node}/{channel}/telemetry`

**Решение:**  
1. Привести history-logger в соответствие с документацией и прошивками:
   - Изменить подписку на `hydro/+/+/+/+/telemetry` (с каналом)
   - Извлечение `channel` из топика вместо `metric_type`
2. Обновить документацию, если формат должен быть другим
3. Проверить все места использования топиков в коде

**Оценка:** 4-6 часов  
**Зависимости:** Нет  
**Статус:** ⏳ Планируется

---

### 12.2. Синхронизация формата payload телеметрии

**Проблема:**  
Несоответствие полей в JSON payload:
- **Прошивки отправляют:** `{"node_id": "...", "channel": "...", "metric_type": "...", "value": ..., "ts": ..., "raw": ..., "stub": ..., "stable": ...}`
- **history-logger ожидает:** `{"metric_type": "...", "value": ..., "timestamp": ..., "channel": ...}` (Pydantic модель)
- **Документация говорит:** `{"value": ..., "metric_type": "...", "ts": ...}`

**Решение:**  
1. Обновить Pydantic модель в history-logger:
   - Принять `ts` как основной формат (вместо `timestamp`)
   - Поддержать обратную совместимость с `timestamp`
   - Добавить поддержку опциональных полей: `node_id`, `raw`, `stub`, `stable`
2. Обновить обработку в `handle_telemetry()` для поддержки обоих форматов
3. Обновить документацию с полным списком полей

**Оценка:** 3-4 часа  
**Зависимости:** Нет  
**Статус:** ✅ Выполнено

**Выполненные изменения:**
1. ✅ Обновлен `TelemetryPayloadModel`:
   - Добавлено поле `ts` (основной формат от прошивок)
   - Сохранено поле `timestamp` (обратная совместимость)
   - Добавлены опциональные поля: `node_id`, `raw`, `stub`, `stable`
2. ✅ Обновлена логика обработки timestamp: приоритет `ts` > `timestamp`
3. ✅ Добавлена автоматическая детекция единиц измерения (секунды/миллисекунды)
4. ✅ Обновлен README.md с описанием всех полей payload

---

### 12.3. Синхронизация формата heartbeat

**Проблема:**  
Проверить соответствие формата heartbeat между прошивками и history-logger.

**Текущее состояние:**
- **Прошивки отправляют:** `{"uptime": ..., "free_heap": ..., "rssi": ...}`
  - `uptime` в секундах (esp_timer_get_time() / 1000)
  - `free_heap` в байтах
- **history-logger ожидает:** `uptime`, `free_heap` (или `free_heap_bytes`), `rssi`
  - Преобразует `uptime` в `uptime_seconds`
  - Преобразует `free_heap` в `free_heap_bytes`

**Решение:**  
1. ✅ Формат совпадает - прошивки отправляют правильные поля
2. Проверить единицы измерения (uptime в секундах, free_heap в байтах)
3. Обновить документацию с точными единицами измерения

**Оценка:** 1-2 часа  
**Зависимости:** Нет  
**Статус:** ✅ Проверено - формат соответствует

---

### 12.4. Синхронизация формата node_hello

**Проблема:**  
Проверить соответствие формата node_hello между прошивками и history-logger.

**Текущее состояние:**
- **Прошивки отправляют:** `{"message_type": "node_hello", "hardware_id": "...", "node_type": "...", "fw_version": "...", "capabilities": [...]}`
- **history-logger ожидает:** `message_type`, `hardware_id`, `node_type`, `fw_version`, `hardware_revision` (опционально), `capabilities`, `provisioning_meta` (опционально)

**Решение:**  
1. ✅ Основные поля совпадают: `message_type`, `hardware_id`, `node_type`, `fw_version`, `capabilities`
2. Добавить опциональные поля в прошивки (если нужно):
   - `hardware_revision` - версия аппаратной платформы
   - `provisioning_meta` - метаданные provisioning
3. Обновить документацию с описанием опциональных полей

**Оценка:** 2-3 часа  
**Зависимости:** Нет  
**Статус:** ⚠️ Частично соответствует - опциональные поля отсутствуют (не критично)

---

### 12.5. Синхронизация формата config_response

**Проблема:**  
Проверить соответствие формата config_response между прошивками и history-logger.

**Текущее состояние:**
- **Прошивки отправляют:**
  - Успех: `{"status": "ACK", "applied_at": ..., "restarted": [...]}`
  - Ошибка: `{"status": "ERROR", "error": "...", "ts": ...}`
- **history-logger ожидает:** `status` (OK/ERROR), `error` (опционально)

**Решение:**  
1. ⚠️ **НЕСООТВЕТСТВИЕ**: прошивки отправляют "ACK", а history-logger ожидает "OK"
2. Варианты решения:
   - Вариант А: Обновить прошивки для отправки "OK" вместо "ACK"
   - Вариант Б: Обновить history-logger для поддержки "ACK" (обратная совместимость)
3. Рекомендация: Вариант Б (поддержать оба формата в history-logger)
4. Обновить документацию с единым форматом

**Оценка:** 2-3 часа  
**Зависимости:** Нет  
**Статус:** ✅ Выполнено

**Выполненные изменения:**
1. ✅ Обновлена обработка `config_response` в `handle_config_response()`:
   - Добавлена поддержка статуса "ACK" (от прошивок)
   - Сохранена поддержка статуса "OK" (обратная совместимость)
   - Проверка: `if status == "OK" or status == "ACK"`

---

### 12.6. Создание тестов синхронизации форматов

**Проблема:**  
Отсутствие автоматических тестов для проверки соответствия форматов.

**Решение:**  
1. Создать unit-тесты в history-logger для проверки парсинга payload от прошивок
2. Создать интеграционные тесты для проверки полного цикла (прошивка → MQTT → history-logger → БД)
3. Добавить валидацию форматов в CI/CD
4. Создать тестовые payload'ы на основе реальных данных от прошивок

**Оценка:** 6-8 часов  
**Зависимости:** 12.1, 12.2, 12.5  
**Статус:** ✅ Выполнено

**Выполненные изменения:**
1. ✅ Создан файл `test_sync_formats.py` с тестами синхронизации форматов
2. ✅ Создан файл `test_format_sync_integration.py` с интеграционными тестами
3. ✅ Все тесты проходят (24/24 теста)

---

### 12.7. Аудит и проверка синхронизации всех форматов

**Проблема:**  
Необходимо провести полный аудит всех форматов сообщений между прошивками и history-logger.

**Текущее состояние:**
- ✅ **Heartbeat** - проверен, соответствует
- ✅ **command_response** - проверен, соответствует (не обрабатывается в history-logger)
- ✅ **status** - проверен, соответствует (не обрабатывается в history-logger)
- ⚠️ **Телеметрия** - несоответствие топика и payload
- ⚠️ **node_hello** - частично соответствует (опциональные поля)
- ⚠️ **config_response** - несоответствие статусов ("ACK" vs "OK")

**Решение:**  
1. ✅ Создана таблица соответствия форматов (см. выше)
2. Исправить найденные несоответствия:
   - Задача 12.1: Синхронизация топиков телеметрии
   - Задача 12.2: Синхронизация payload телеметрии
   - Задача 12.5: Синхронизация config_response (поддержать "ACK" и "OK")
3. Создать отчет о несоответствиях с приоритетами
4. Обновить документацию с актуальными форматами

**Оценка:** 2-3 часа (после исправления несоответствий)  
**Зависимости:** 12.1, 12.2, 12.5  
**Статус:** ⏳ Планируется

---

### Итоговая сводка проверки синхронизации

**Проверено и соответствует:**
- ✅ Heartbeat - формат полностью соответствует
- ✅ command_response - формат соответствует (не обрабатывается в history-logger)
- ✅ status - формат соответствует (не обрабатывается в history-logger)

**Исправлено:**
- ✅ **Телеметрия (топик)** - исправлено: history-logger подписывается на `hydro/+/+/+/+/telemetry`
- ✅ **Телеметрия (payload)** - исправлено: history-logger поддерживает `ts` (основной формат)
- ✅ **config_response** - исправлено: history-logger поддерживает "ACK" (основной формат)

**Частично соответствует:**
- ⚠️ **node_hello** - опциональные поля отсутствуют (не критично)

**Приоритет исправления:**
1. **Критично:** Телеметрия (топик и payload) - без этого телеметрия не обрабатывается
2. **Важно:** config_response - может привести к неправильной обработке статусов
3. **Низкий:** node_hello - опциональные поля не критичны

---

## 13. СЛЕДУЮЩИЕ ШАГИ

1. ✅ **Завершено:** Синхронизация форматов с history-logger (Фаза 0)
2. ✅ **Завершено:** Создание node_framework (Фаза 1.1) - 100% выполнено
   - ✅ Все компоненты реализованы
   - ✅ Полная интеграция с ph_node (config, commands, telemetry)
   - ✅ Полная интеграция с ec_node (config, commands, telemetry)
   - ✅ Полная интеграция с climate_node (config, commands, telemetry)
   - ✅ Полная интеграция с pump_node (config, commands, telemetry)
   - ✅ Все четыре ноды успешно скомпилированы
   - ⏳ Осталось: тестирование на реальном железе
3. ✅ **Завершено:** Компиляция ph_node с node_framework - успешно
4. ✅ **Завершено:** Интеграция ec_node с node_framework - успешно скомпилирован
5. ✅ **Завершено:** Интеграция climate_node с node_framework - успешно скомпилирован
6. ✅ **Завершено:** Интеграция pump_node с node_framework - успешно скомпилирован
7. ✅ **Завершено:** Рефакторинг NodeConfig во всех нодах (Фаза 1.2) - реализовано через node_framework
8. ✅ **Завершено:** Унификация обработки команд (Фаза 1.3) - реализовано через node_framework
9. ✅ **Завершено:** Унификация публикации телеметрии (Фаза 1.4) - реализовано через node_framework
10. ✅ **Завершено:** Улучшение обработки ошибок (Фаза 2, задача 3.1) - добавлены уровни ошибок, отправка через MQTT
11. ✅ **Завершено:** Реализация Safe Mode (Фаза 2, задача 3.2) - интеграция во все ноды
12. ✅ **Завершено:** Улучшение Watchdog (Фаза 2, задача 3.3) - создан унифицированный компонент, интегрирован в node_framework, обновлен ph_node и heartbeat_task (90%)
13. ✅ **Завершено:** Оптимизация памяти (Фаза 2, задача 2.1) - создан компонент memory_pool, интегрирован в node_framework, добавлены метрики в heartbeat (90%)

---

## 14. ОБНОВЛЕННЫЙ ПЛАН РЕАЛИЗАЦИИ

### Фаза 0: Синхронизация с history-logger (1 неделя) - КРИТИЧНО ✅ ЗАВЕРШЕНО

**Цель:** Устранить несоответствия форматов между прошивками и history-logger

1. ✅ Задача 12.1: Синхронизация формата топиков (4-6 часов) - ВЫПОЛНЕНО
2. ✅ Задача 12.2: Синхронизация формата payload (3-4 часа) - ВЫПОЛНЕНО
3. ✅ Задача 12.3: Синхронизация heartbeat (1-2 часа) - ПРОВЕРЕНО
4. ✅ Задача 12.4: Синхронизация node_hello (2-3 часа) - ПРОВЕРЕНО
5. ✅ Задача 12.5: Синхронизация config_response (2-3 часа) - ВЫПОЛНЕНО
6. ✅ Задача 12.7: Аудит всех форматов (4-6 часов) - ВЫПОЛНЕНО
7. ✅ Задача 12.6: Тесты синхронизации (6-8 часов) - ВЫПОЛНЕНО

**Итого:** 22-32 часа - ✅ ЗАВЕРШЕНО

---

### Фаза 1: Фундамент (2-3 недели)

**Цель:** Создать унифицированный фреймворк и устранить критическое дублирование

1. ✅ Задача 1.1: Создание node_framework (16-20 часов)
2. ✅ Задача 1.2: Рефакторинг NodeConfig (8-12 часов)
3. ✅ Задача 1.3: Унификация команд (8-12 часов)
4. ✅ Задача 1.4: Унификация телеметрии (6-8 часов)

**Итого:** 38-52 часа

---

**Последнее обновление:** 2025-01-27  
**Автор:** AI Agent (на основе анализа кода, документации и history-logger)

