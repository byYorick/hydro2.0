# BACKEND_ARCH_FULL.md
# Полная архитектура Backend 2.0 (Детальный документ)

Документ описывает архитектуру backend-системы 2.0:

- как устроены слои;
- какие есть модули;
- как backend интегрируется с Python-сервисом, MQTT и фронтендом;
- какие правила должны соблюдать разработчики и ИИ-агенты.

---

## 1. Назначение Backend

Backend — **единый центр правды** и точка входа для пользователей.

Он отвечает за:

- хранение структуры теплиц, зон, узлов и каналов;
- хранение рецептов, фаз, расписаний;
- авторизацию и управление пользователями;
- предоставление REST/WS API фронтенду и Android;
- взаимодействие с Python-сервисом (конфигурация, команды, события);
- аудит и безопасность (права доступа, журналы действий).

**Важно:** ни одна ESP-нода не принимает агрономических решений. Все расчёты — в зоне ответственности Python-сервиса и/или backend-домена.

---

## 2. Архитектурные слои backend

```text
HTTP / WebSocket / Jobs
 ↓
Controllers (Laravel)
 ↓
Application Services (Use Cases)
 ↓
Domain (Entities, Value Objects, Policies)
 ↓
Repositories (Eloquent / Query Builders)
 ↓
PostgreSQL
```

### 2.1. Controllers

- Принимают HTTP-запросы (REST, Inertia).
- Выполняют базовую валидацию входящих данных.
- Вызывают Application Services.
- Возвращают JSON/ресурсы или Inertia-страницы.

### 2.2. Application Services (Use Cases)

- Реализуют сценарии уровня бизнеса: 
 «создать зону», «назначить рецепт», «запустить калибровку pH» и т.п.
- Не содержат логики HTTP/Response.
- Работают с доменными сущностями и репозиториями.

### 2.3. Domain Layer

- Сущности: `Greenhouse`, `Zone`, `DeviceNode`, `Channel`, `Recipe`, `RecipePhase`, `Alert`, `User`, `Role` и т.п.
- Политики и инварианты:
 - нельзя удалить зону с активным рецептом без перевода в безопасное состояние;
 - нельзя назначить узел в две зоны одновременно;
 - recipe-фазы не должны пересекаться по времени.

### 2.4. Repositories / Data Access

- Eloquent-модели + кастомные репозитории, где нужно.
- Чётко разделённые чтение/запись, где оправдано (CQRS light):
 - `ZoneReadRepository` (сложные выборки);
 - `ZoneWriteService` (создание/обновление).

---

## 3. Основные модули backend

### 3.1. Модуль конфигурации (Greenhouses / Zones / Nodes / Channels)

Отвечает за:

- CRUD по теплицам/зонам/узлам/каналам;
- связь узлов с зонами;
- валидацию конфигурации при изменениях;
- публикацию обновлений для Python-сервиса (через очередь/события).

### 3.2. Recipe & Scheduler Module

- Управление рецептами и фазами:
 - создание рецептов;
 - редакция фаз;
 - назначение рецептов на зоны;
 - ручные переводы между фазами.
- Интеграция с Python-контроллерами: 
 backend фиксирует активный рецепт → Python-сервис подтягивает его и применяет.

### 3.3. Telemetry & History Module

- Чтение данных из таблиц `telemetry_samples` и `telemetry_last`.
- Агрегирование и подготовка данных для графиков и отчётов.
- API для фронтенда и аналитики (см. `REST_API_REFERENCE.md`).

### 3.4. Alerts & Events Module

- Хранение событий (`events`) и алертов (`alerts`).
- Связь с зонами/узлами/пользователями.
- Маркировка алертов как «прочитано», «подтверждено» и т.п.
- Интеграция с внешними каналами уведомлений (Telegram, email).

### 3.5. Users & Auth Module

- Регистрация, авторизация (обычно JWT или Laravel Sanctum).
- Роли и права: админ, оператор, гость и т.п.
- Привязка пользователей к теплицам/зонам (мульти-арендная модель по желанию).

### 3.6. Integration & AI Module

- Тонкий слой API для Python-сервиса (REST или gRPC).
- API/Endpoint-ы для AI-сервисов:
 - запрос оптимизации рецепта;
 - прогнозирование урожайности;
 - диагностика системы.

---

## 4. Взаимодействие Backend ↔ Python-сервис

### 4.1. Поток конфигурации

- Backend является основным владельцем конфигурации.
- Python-сервис периодически либо по вебхуку/событию:
 - делает запросы вида `/api/system/config/full` или `/api/zones/{id}/config`;
 - кэширует конфигурацию локально;
 - реагирует на изменения (перезапуск контроллеров зон и т.п.).

### 4.2. Поток телеметрии

- Python-сервис **записывает** данные сразу в PostgreSQL.
- Backend читает данные из БД, не обращается напрямую к MQTT.
- Для realtime UI можно использовать:
 - PostgreSQL LISTEN/NOTIFY;
 - отдельный WebSocket-gateway;
 - Laravel Broadcasting.

### 4.3. Команды от пользователя к узлам

1. Пользователь на UI вызывает действие (например, «включить насос на 10 секунд»).
2. Backend:
 - валидирует права;
 - регистрирует намерение/команду в БД (таблица `commands`);
 - отдаёт Python-сервису (через очередь/Endpoint).
3. Python-сервис публикует команду в MQTT в нужный топик.
4. Результат исполнения (status/event) возвращается через БД/событие обратно на backend и UI.

---

## 5. Интеграция с фронтендом (Inertia + Vue 3)

- Все страницы UI = Inertia-views.
- Контроллеры возвращают Inertia-ответы с данными; Vue-компоненты рендерят всё на стороне клиента.
- Фронт **никогда** не ходит в MQTT и Python-сервис напрямую — только через backend API.

Структура проекта описана в `TECH_STACK_LARAVEL_INERTIA_VUE3_PG.md`.

---

## 6. Требования к ИИ-агентам при работе с backend

1. **Не изменять доменную модель без правки `DATA_MODEL_REFERENCE.md` и миграций.**
2. **Не внедрять тяжёлую логику в контроллеры.** 
 Всегда выносить в Application Services / домен.
3. **Не создавать обходные пути в обход Python-сервиса.** 
 Любое взаимодействие с MQTT должно идти через Python-слой.
4. **Соблюдать единый стиль код-стайла Laravel и структуру каталогов.**
5. **Все новые публичные эндпоинты описывать в `REST_API_REFERENCE.md` и `API_SPEC_FRONTEND_BACKEND_FULL.md`.**

---

## 7. Резюме

Backend 2.0 — это:

- владелец конфигурации и истории;
- единая точка входа для UI, Android и внешних систем;
- надёжный партнёр для Python-сервиса, который управляет зонами;
- хорошо структурированная Laravel-система, расширяемая ИИ-агентами по чётким правилам.
