# E2E Authorization Master Task

## Задача

Реализовать единую систему авторизации для E2E тестов с автоматическим управлением токенами, единым источником истины для API и WebSocket, и защитой от inconsistent guards и auth-bypass'ов.

## Требования

### 1. Единый источник истины

- **API и WS используют одинаковые токены** (Sanctum PAT)
- **Один AuthClient** управляет всеми токенами
- **Нет разных auth-механизмов** для разных компонентов

### 2. Автоматическое управление токенами

- Токен получается автоматически при первом использовании
- Токен кешируется на время выполнения теста
- Токен автоматически обновляется при истечении
- При 401 токен автоматически обновляется и запрос повторяется

### 3. Token-Agnostic сценарии

- **Сценарии не знают о токенах**
- Нет хардкода токенов в YAML
- Все токены управляются автоматически

### 4. Защита от inconsistent guards

- **Нельзя отключать middleware** ради тестов
- **Нельзя использовать APP_DEBUG** как auth-bypass
- **Нельзя иметь разные auth-механизмы** для API и WS
- Любые изменения auth-логики должны ломать тесты (и это хорошо)

## Реализация

### Компоненты

1. **E2E Auth Bootstrap**
   - Artisan команда: `php artisan e2e:auth-bootstrap`
   - API endpoint: `POST /api/e2e/auth/token` (только в testing/e2e)
   - Создает пользователя `e2e@test.local` с указанной ролью
   - Генерирует Sanctum токен

2. **AuthClient** (`tests/e2e/runner/auth_client.py`)
   - Singleton для управления токенами
   - `get_token()`: получает токен через API или Artisan
   - `refresh_token_if_needed()`: обновляет токен при истечении
   - `handle_401_error()`: принудительно обновляет токен
   - `get_auth_headers()`: возвращает заголовки авторизации

3. **APIClient Integration**
   - Принимает `auth_client` в конструкторе
   - Автоматически добавляет `Authorization: Bearer <token>` к каждому запросу
   - При 401: вызывает `auth_client.handle_401_error()` и повторяет запрос
   - Если повторный запрос тоже 401 → выбрасывает `AuthenticationError`

4. **WSClient Integration**
   - Принимает `auth_client` в конструкторе
   - Использует токен при подключении (в заголовках)
   - При подписке на приватный канал: вызывает `/broadcasting/auth` с токеном
   - Проверяет успешную авторизацию канала

5. **E2ERunner Integration**
   - Инициализирует `AuthClient` в начале прогона
   - Передает `AuthClient` в `APIClient` и `WSClient`
   - Обрабатывает `AuthenticationError` как ошибку теста

### E2E Сценарии

1. **E2E_AUTH_01_valid_token**
   - Получение токена
   - Вызов защищённого API
   - Подключение к WS
   - Подписка на приватный канал
   - Получение события

2. **E2E_AUTH_02_expired_token**
   - Подмена токена на невалидный
   - API → 401
   - Автоматический re-auth
   - Повторный запрос проходит

3. **E2E_AUTH_03_ws_forbidden**
   - Попытка подписки без токена
   - Ожидание FAIL с понятной ошибкой

## Проверка на Inconsistencies

### Что проверяется

1. **Inconsistent guards**:
   - API и WS используют одни и те же токены
   - Оба используют `AuthClient`
   - Оба обрабатывают 401 одинаково

2. **Разные требования к API и WS**:
   - API требует токен → WS тоже требует токен
   - API обновляет токен при 401 → WS должен делать то же самое

3. **"Магические" bypass'ы авторизации**:
   - Нет отключенных middleware для тестов
   - Нет `APP_DEBUG` проверок в auth-логике
   - Нет environment-based bypass'ов (кроме безопасного `E2EAuthController`)

### Что делать при обнаружении

Если найдено inconsistency или bypass:

1. **Унифицировать**:
   - Привести API и WS к единому механизму
   - Использовать один `AuthClient` везде

2. **Задокументировать**:
   - Объяснить почему выбрано такое решение
   - Убедиться что это не bypass

3. **Покрыть тестом**:
   - Добавить E2E сценарий
   - Убедиться что тест ломается при изменении auth-логики

## Выходные артефакты

### Обязательные

- ✅ `doc_ai/E2E_AUTH_MASTER_TASK.md` (этот файл)
- ✅ `tests/e2e/runner/auth_client.py` - AuthClient реализация
- ✅ `tests/e2e/scenarios/E2E_AUTH_01_valid_token.yaml` - Тест валидного токена
- ✅ `tests/e2e/scenarios/E2E_AUTH_02_expired_token.yaml` - Тест re-auth
- ✅ `tests/e2e/scenarios/E2E_AUTH_03_ws_forbidden.yaml` - Тест ошибки WS
- ✅ `tools/testing/bootstrap_e2e_auth.sh` (или Artisan команда `e2e:auth-bootstrap`)
- ✅ `docs/testing/AUTH_IN_E2E.md` - Документация для разработчиков

### Дополнительные

- `tests/e2e/runner/AUTH_CLIENT.md` - Документация AuthClient
- `tests/e2e/runner/API_CLIENT_AUTH.md` - Документация авторизации в APIClient
- `tests/e2e/runner/WS_AUTH.md` - Документация авторизации в WSClient

## Итоговое состояние системы

После выполнения:

### ✅ E2E тесты никогда не падают из-за авторизации

- Токены управляются автоматически
- Re-auth происходит прозрачно
- Ошибки авторизации обрабатываются правильно

### ✅ API и WS используют один источник истины

- Оба используют Sanctum PAT токены
- Оба используют `AuthClient`
- Оба обрабатывают 401 одинаково

### ✅ Любые изменения auth-логики сразу ломают тесты (и это хорошо)

- E2E_AUTH_* сценарии покрывают все случаи
- Inconsistent guards обнаруживаются тестами
- Bypass'ы обнаруживаются тестами

## Запреты

### ❌ Нельзя отключать middleware ради тестов

Все middleware должны работать в тестах так же, как в продакшене.

### ❌ Нельзя использовать APP_DEBUG как auth-bypass

`APP_DEBUG` не влияет на авторизацию.

### ❌ Нельзя хардкодить токены

Все токены получаются динамически через `AuthClient`.

### ❌ Нельзя иметь разные auth-механизмы для API и WS

Оба используют один источник истины: Sanctum PAT токены.

## Статус

✅ **Реализовано**

Все компоненты реализованы и интегрированы. E2E сценарии готовы к использованию.

