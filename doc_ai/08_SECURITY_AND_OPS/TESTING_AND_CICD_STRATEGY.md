# TESTING_AND_CICD_STRATEGY.md
# Стратегия тестирования и CI/CD для Hydro 2.0

Документ описывает, **как мы проверяем, что система работает**,
и как это интегрируется в пайплайны CI/CD.

---

## 1. Зоны тестирования

1. Прошивка узлов (ESP32):
 - модульные тесты логики;
 - интеграционные тесты с железом (по возможности);
 - smoke-тесты перед релизом.

2. Backend:
 - unit-тесты бизнес-логики;
 - интеграционные тесты (MQTT ↔ backend ↔ БД);
 - API-тесты (REST/WebSocket).

3. Клиенты (web + Android):
 - unit-тесты (ViewModel/логика),
 - UI-тесты для ключевых сценариев.

---

## 2. Прошивка узлов

### 2.1. Модульные тесты

- Используем `idf.py unit-test` и GoogleTest/Unity (в зависимости от стекa).
- Тестируем:
 - state machine Wi-Fi и MQTT (без реального железа);
 - обработку очередей событий;
 - фильтрацию и нормализацию измерений (набор тестовых входов/выходов).

### 2.2. Интеграционные тесты/лабораторные стенды

- Для ключевых типов нод (pH, EC, климат) создаются стенды, где:
 - прошивка подключена к реальным датчикам/эмуляторам;
 - проверяются:
 - стабильность соединения,
 - корректность передачи в MQTT,
 - реакция на ошибочные ситуации (обрыв сенсора, плохой Wi-Fi).

---

## 3. Backend

### 3.1. Unit/feature tests

- Стандартный стек тестирования фреймворка (например, PHPUnit и feature-тесты в Laravel).
- Покрываем:
 - доменную логику рецептов,
 - привязку зон/узлов,
 - генерацию алертов.

### 3.2. Интеграционные тесты

- Поднимается docker-compose:
 - backend,
 - PostgreSQL,
 - MQTT-брокер.
- Набор сценариев:
 - симуляция узлов через Python-скрипты (публикация в MQTT),
 - проверка:
 - что backend правильно пишет данные в БД,
 - что генерируются нужные события realtime,
 - что создаются алерты.

---

## 4. Клиентские приложения

### 4.1. Web (frontend)

- Unit-тесты компонентов и store (Vue/React), где:
 - проверяется обработка событий realtime,
 - рендер карточек зон/узлов/алертов.
- E2E-тесты для ключевых сценариев:
 - логин,
 - просмотр теплицы/зоны,
 - просмотр и подтверждение алерта.

### 4.2. Android

- Unit-тесты ViewModel и use-case’ов:
 - обработка REST-ответов,
 - применение событий realtime.
- Инструментальные тесты для основных экранов:
 - provisioning-flow,
 - просмотр зоны,
 - алерты.

---

## 5. Пайплайны CI/CD (на уровне принципов)

### 5.1. Общие этапы

Для каждого репозитория:

1. **Lint/format**:
 - прошивка: clang-format, C lint;
 - backend: PHP-CS-Fixer/ESLint;
 - frontend/Android: линтеры по стеку.

2. **Unit-тесты**:
 - запуск на PR/merge.

3. **Интеграционные тесты**:
 - для backend (docker-compose),
 - по расписанию (ночные прогоны),
 - перед релизом.

4. **Сборка артефактов**:
 - прошивки (.bin/.elf),
 - Docker-образы,
 - Android APK/AAB.

5. **Деплой**:
 - на staging;
 - затем на production (ручной или автоматизированный promote).

### 5.2. Прошивки

- На каждый merge в main/release-ветку:
 - собираются релизные прошивки;
 - версии прошивок инкрементируются;
 - артефакты загружаются в хранилище (OTA-сервер).

---

## 6. Использование ИИ в тестировании

1. ИИ-агенты могут:
 - генерировать тест-кейсы по спецификациям;
 - создавать skeleton’ы тестов;
 - предлагать негативные сценарии.

2. Но:
 - финальное решение о покрытии/критичности остаётся за человеком/мета-агентом;
 - результаты автогенерации тестов должны проходить ревью.

---

## 7. Требования к ИИ-агенту

1. При добавлении нового функционала ИИ должен:
 - предложить, как его тестировать,
 - указать, в каких слоях нужны тесты.
2. Нельзя добавлять сложные фичи без минимального набора тестов.
3. Любое изменение контрактов (MQTT/REST/WebSocket) должно сопровождаться
 обновлением соответствующих тестов.
