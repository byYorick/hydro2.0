# TASKS_FOR_AI_AGENTS.md
# Правила постановки задач ИИ‑агентам для проекта Hydro 2.0

Этот документ описывает, как формулировать задачи для ИИ‑агентов (ChatGPT и других моделей),
которые участвуют в разработке Hydro 2.0: прошивок, бэкенда, документации, тестов.

Цель — добиться предсказуемого и воспроизводимого результата:  
один и тот же запрос, выполненный разными агентами/в разное время,
должен приводить к совместимому с архитектурой результату.

---

## 1. Общие принципы постановки задач

1. **Задача всегда контекстна**  
   - ИИ‑агенту нужно дать:
     - архитектурный контекст (какой это слой системы и зачем он нужен);
     - ссылку на спецификацию (конкретный `.md`‑файл из репозитория);
     - информацию о том, где лежит код (путь до файлов/директорий).

2. **Запрос всегда конкретен**
   - Нельзя формулировать задачи вроде:  
     “Сделай прошивку для гидропонной системы”.  
   - Нужно:  
     - ограничить задачу конкретной нодой;
     - указать точные файлы/модули;
     - описать ожидаемый формат результата.

3. **Результат всегда проверяем**
   - В задаче обязательно прописываются критерии приёмки:
     - какие функции должны существовать;
     - какие входные/выходные параметры;
     - какие сценарии должны быть покрыты.

4. **Одна задача — один уровень детализации**
   - Если задача получается слишком большой, её нужно распилить на подзадачи
     и завести отдельные запросы/файлы для каждой.

---

## 2. Формат задач для ИИ‑агентов

Рекомендуемый формат задачи в `.md`‑файле:

1. `Название задачи`
2. `Контекст`
3. `Текущая ситуация`
4. `Цель`
5. `Входные данные`
6. `Ожидаемый результат`
7. `Ограничения и требования`
8. `Формат ответа`

Ниже — детальная расшифровка каждого раздела.

### 2.1. Название задачи

Кратко, но максимально конкретно.  
Примеры:

- `Реализация MQTT‑клиента для pH‑ноды`  
- `Добавление экрана калибровки pH на OLED`  
- `Создание REST‑эндпоинта /nodes/{id}/telemetry`  
- `Генерация юнит‑тестов для модуля контроля EC`

### 2.2. Контекст

Краткое описание:

- где в архитектуре находится этот компонент (нода, бэкенд, фронтенд, ИИ‑слой);
- на какие документы нужно опираться (список `.md`‑файлов);
- на какой язык/стек нацелен результат.

Пример:

> Эта задача относится к прошивке pH‑ноды (ESP32, C, ESP‑IDF).  
> Нода описана в `02_HARDWARE_FIRMWARE/NODE_ARCH_FULL.md` и `02_HARDWARE_FIRMWARE/NODE_CHANNELS_REFERENCE.md`.  
> MQTT‑транспорт и топики описаны в `03_TRANSPORT_MQTT/MQTT_SPEC_FULL.md`.  
> Требуется реализовать модуль MQTT‑клиента в прошивке.

### 2.3. Текущая ситуация

Кратко описывается, что уже есть:

- какие файлы/модули существуют;
- какие функции уже реализованы;
- какие ограничения/проблемы наблюдаются.

Пример:

> В каталоге `node_ph/net` уже есть черновик `mqtt_client_node_common.c`,
> но он пока не реализует автоматический реконнект и обработку всех топиков,
> описанных в `03_TRANSPORT_MQTT/MQTT_SPEC_FULL.md`.

### 2.4. Цель

Чёткое описание того, что должно измениться после выполнения задачи.

Пример:

> Цель — получить рабочий модуль MQTT‑клиента, который:
> - подключается к брокеру;
> - подписывается на требуемые топики;
> - публикует телеметрию ноды;
> - корректно обрабатывает переподключения.

### 2.5. Входные данные

Здесь перечисляется всё, что ИИ‑агенту нужно для работы:

- пути к файлам;
- выдержки из документации (либо указание, что агент имеет к ним доступ);
- пример формата сообщений/структур данных.

При необходимости сюда можно вставить фрагменты кода, но лучше
указывать путь к файлу и кратко описывать, что в нём важно.

### 2.6. Ожидаемый результат

Здесь фиксируется:

- какие файлы должны быть добавлены или изменены;
- какие функции/классы/структуры должны существовать;
- как именно должен выглядеть формат ответа (например, “дай полный содержимое файла”).

Пример:

> Ожидается:
> - полный файл `node_ph/net/mqtt_client_node_common.c` с реализацией;
> - при необходимости — заголовочный файл `node_ph/net/mqtt_client_node_common.h`;
> - описание новых/изменённых функций.

### 2.7. Ограничения и требования

Примеры ограничений:

- придерживаться архитектурных принципов из `DEV_CONVENTIONS.md`;
- не использовать динамическое выделение памяти в горячих путях;
- не менять публичный интерфейс других модулей без явного указания.

### 2.8. Формат ответа

Здесь задаётся строгий формат:

- код — в отдельных блоках с указанием целевого пути (`// path: ...`);
- краткое текстовое резюме изменений;
- при необходимости — список дальнейших задач.

Пример:

> Формат ответа:  
> 1. Короткое резюме (2–3 пункта).  
> 2. Полный текст файлов с указанием пути, например:  
>    ```c
>    // path: node_ph/net/mqtt_client_node_common.c
>    ...код...
>    ```  
> 3. Список дополнительных улучшений, которые можно сделать позже.

---

## 3. Типы задач для ИИ‑агентов

В рамках проекта используются несколько типовых классов задач. Ниже — краткое описание
каждого класса и рекомендации по формулировке.

### 3.1. Генерация нового кода

Примеры:

- новая прошивочная нода или её модуль;
- новый REST‑эндпоинт на бэкенде;
- новый компонент Android‑приложения.

Особенности постановки задачи:

- максимально точное указание целевого языка/фреймворка;
- ссылки на архитектурные документы;
- требования к структуре каталогов и файлов.

### 3.2. Рефакторинг и улучшения

Примеры:

- разнести “божественный модуль” на несколько файлов;
- убрать дублирование кода;
- привести имена и стили к конвенциям.

Особенности:

- обязательное перечисление текущих проблем (что именно мешает);
- указание, что **публичный API менять нельзя**, если это критично;
- требование привести примеры “до/после” или дать полный обновлённый файл.

### 3.3. Документация и спецификации

Примеры:

- заполнение или расширение `.md`‑файлов;
- генерация описания протоколов, форматов сообщений, пользовательских сценариев.

Особенности:

- точный список разделов, которые нужно добавить/заполнить;
- требование не использовать заглушки и не оставлять фразы “заполнить позже”;
- указание, в каком стиле писать (техническая документация, без маркетинга).

### 3.4. Тесты и проверки

Примеры:

- генерация юнит‑тестов для модуля;
- генерация чек‑листов для ручного тестирования ноды или мобильного приложения;
- создание unit/component тестов для Vue компонентов (Vitest + Vue Test Utils);
- создание интеграционных тестов для страниц Inertia;
- создание E2E тестов (Playwright).

Особенности:

- чёткое указание того, что именно нужно тестировать;
- требование фиксировать ожидаемое поведение и граничные случаи;
- для фронтенда: использование моков для axios, Inertia, Pinia stores;
- структура тестов должна соответствовать `07_FRONTEND/FRONTEND_TESTING.md`.

---

## 4. Шаблоны задач

Ниже приведены готовые шаблоны, которые можно копировать и заполнять.

### 4.1. Шаблон: генерация модуля прошивки ноды (ESP32)

```markdown
# Задача: <краткое название>

## Контекст
- Компонент: прошивка ноды <название ноды> (ESP32, C, ESP‑IDF).
- Архитектура: см. `02_HARDWARE_FIRMWARE/NODE_<...>_ARCH.md`.
- Транспорт и протоколы: см. `03_TRANSPORT_MQTT/MQTT_SPEC_FULL.md`.

## Текущая ситуация
- В каталоге `<путь>` есть файлы: `<список>`.
- Сейчас реализовано: `<кратко>`.

## Цель
- Получить модуль, который делает:
  - `<пункт 1>`
  - `<пункт 2>`

## Входные данные
- Язык: C, ESP‑IDF.
- Целевой путь файлов: `<путь>`.
- Особенности железа/датчиков: `<кратко>`.

## Ожидаемый результат
- Полные файлы:
  - `<путь к файлу 1>`
  - `<путь к файлу 2>` (если нужен)

## Ограничения и требования
- Соблюдать `DEV_CONVENTIONS.md` (структура кода, логирование, обработка ошибок).
- Не менять существующие публичные функции без необходимости.

## Формат ответа
1. Краткое резюме изменений.
2. Полные тексты файлов в блоках кода с указанием пути, например:
   ```c
   // path: <путь>
   ...код...
   ```
3. Краткий список возможных следующих шагов.
```

### 4.2. Шаблон: изменение/рефакторинг существующего модуля

```markdown
# Задача: рефакторинг модуля <имя>

## Контекст
- Компонент: `<описание>`.
- Архитектурные документы: `<список файлов>`.

## Текущая ситуация
- Существующий файл: `<путь>`.
- Проблемы:
  - `<проблема 1>`
  - `<проблема 2>`

## Цель
- Улучшить код так, чтобы:
  - `<требование 1>`
  - `<требование 2>`

## Входные данные
- Текущая версия файла (см. `<путь>`).

## Ожидаемый результат
- Обновлённый полный файл `<путь>`.

## Ограничения и требования
- Публичный API должен остаться совместимым, если не указано обратное.

## Формат ответа
- Краткое резюме изменений.
- Полный код файла в блоке с указанием пути.
```

### 4.3. Шаблон: задача на документацию

```markdown
# Задача: дополнить документацию <название>

## Контекст
- Документ: `<путь к .md>`.
- Связанные документы: `<список>`.

## Текущая ситуация
- Сейчас в документе не хватает разделов:
  - `<раздел 1>`
  - `<раздел 2>`

## Цель
- Заполнить/расширить документ так, чтобы он покрывал:
  - `<аспект 1>`
  - `<аспект 2>`

## Входные данные
- Текущая архитектура: `<ссылка или краткое описание>`.

## Ожидаемый результат
- Полный текст файла `<путь>` в обновлённом виде.

## Ограничения и требования
- Не использовать заглушки и общие фразы.
- Стиль — строгая техническая документация.

## Формат ответа
- Только обновлённый текст файла.
```

---

## 5. Проверка и ревью задач для ИИ

Перед тем как отправить задачу ИИ‑агенту, желательно проверить:

1. Есть ли у задачи чёткая цель.
2. Достаточно ли контекста, чтобы агент не “фантазировал” архитектуру заново.
3. Ясно ли описан формат ответа.
4. Не просим ли мы сделать “всё сразу” вместо одного конкретного шага.

Для критичных задач рекомендуется дополнительный шаг:  
один ИИ‑агент генерирует решение, другой проверяет его на соответствие архитектуре,
а человек принимает финальное решение о влитии изменений.
