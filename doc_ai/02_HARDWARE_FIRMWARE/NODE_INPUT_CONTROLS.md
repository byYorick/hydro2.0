# NODE_INPUT_CONTROLS.md
# Абстракция локального ввода на узле
# Кнопки • Энкодер • События • Машина состояний

Документ задаёт **единый интерфейс ввода** для всех узлов 2.0.

Цели:

- дать абстракцию поверх железа (кнопки, энкодер и т.п.);
- гарантировать стабильные и предсказуемые события для UI;
- не привязывать UI к конкретному железу.


Compatible-With: Protocol 2.0, Backend >=3.0, Python >=3.0, Database >=3.0, Frontend >=3.0.
Breaking-change: legacy форматы/алиасы удалены, обратная совместимость не поддерживается.

---

# 1. Аппаратные варианты

Система допускает несколько реализаций ввода:

1. **Ротари-энкодер с кнопкой**:
 - энкодер генерирует шаги `LEFT` / `RIGHT`,
 - осевое нажатие — `CLICK` / `LONG_CLICK`.

2. **Набор кнопок**:
 - две кнопки: `UP`, `DOWN`, 
 - третья (опционально): `OK` / `MENU`.

3. Другие варианты (тач-кнопки и т.п.) могут быть реализованы,
 если соблюдают общий протокол событий.

Все аппаратные реализации **маскируются** в унифицированные события ввода.

---

# 2. Абстрактные события ввода

Тип событий:

```c
typedef enum {
 UI_INPUT_NONE = 0,
 UI_INPUT_LEFT,
 UI_INPUT_RIGHT,
 UI_INPUT_CLICK,
 UI_INPUT_LONG_CLICK,
 UI_INPUT_BACK
} ui_input_event_t;
```

Требования:

- все события **должны** отправляться в очередь `ui_event_queue`;
- UI не должен опрашивать GPIO напрямую.

---

# 3. Логика работы input-task

Задача: `input_task`.

Обязанности:

- инициализация GPIO/энкодера,
- дебаунс сигналов,
- распознавание короткого/длинного нажатия,
- ограничение частоты событий (anti-spam),
- отправка `ui_input_event_t` в `ui_event_queue`.

Рекомендуемый период: 5–10 мс (опрос GPIO).

---

# 4. Сопоставление железа и событий (пример)

## 4.1. Энкодер

- Поворот по часовой стрелке → `UI_INPUT_RIGHT`
- Поворот против часовой → `UI_INPUT_LEFT`
- Короткое нажатие (50–500 мс) → `UI_INPUT_CLICK`
- Длинное нажатие (>1.5 сек) → `UI_INPUT_LONG_CLICK`

## 4.2. Три кнопки

- Кнопка `UP` → `UI_INPUT_RIGHT`
- Кнопка `DOWN` → `UI_INPUT_LEFT`
- Кнопка `OK` коротко → `UI_INPUT_CLICK`
- Кнопка `OK` долго → `UI_INPUT_LONG_CLICK`

(Допускается иной маппинг, если он остаётся **консистентным** во всей системе.)

---

# 5. Специальные комбинации

Для системных функций ввод определяет стандартные комбинации:

- **Сброс Wi-Fi / вход в provisioning**:
 - удержание `UI_INPUT_LONG_CLICK` на экране NORMAL ≥ 5 сек;
- **Вход в режим калибровки**:
 - последовательные `CLICK`+`LONG_CLICK` (в зависимости от UX),
 - или выбор через меню.

Реализация:

- `input_task` генерирует события,
- логика интерпретации (калибровка / сброс Wi-Fi) лежит в слое **UI / системной логики**, 
 но комбинации и тайминги должны быть описаны единообразно.

---

# 6. Требования к ИИ-агенту

1. ИИ не имеет права добавлять прямые обращения к GPIO/энкодеру в UI или других задачах, кроме `input_task`.
2. Любое новое аппаратное устройство ввода должно:
 - быть инкапсулировано в отдельный модуль `input_driver_xxx.c`,
 - генерировать только `ui_input_event_t`.
3. Время и пороги длительности нажатий должны быть вынесены в константы/конфиг
 и не хардкодиться в нескольких местах.
4. Логика специальных комбинаций (сброс Wi-Fi, калибровка) должна быть
 согласована с документами `NODE_OLED_UI_SPEC.md` и `WIFI_PROVISIONING_FIRST_RUN.md`.
