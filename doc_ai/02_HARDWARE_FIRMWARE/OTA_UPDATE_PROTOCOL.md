# OTA_UPDATE_PROTOCOL.md
# Полная спецификация OTA-обновления узлов ESP32 для системы 2.0

Документ описывает безопасный протокол OTA-обновления прошивок узлов ESP32.

Цели:

- централизованное обновление всех узлов;
- контроль версии прошивок;
- безопасный откат при неудаче;
- минимальное влияние на работу теплицы.


Compatible-With: Protocol 2.0, Backend >=3.0, Python >=3.0, Database >=3.0, Frontend >=3.0.
Breaking-change: legacy форматы/алиасы удалены, обратная совместимость не поддерживается.

---

## 1. Общая схема

Участники:

- **Backend (Laravel)** — хранит бинарники, версии и историю обновлений.
- **Python-сервис** — инициирует обновления, следит за статусами.
- **ESP32-ноды** — принимают команды и скачивают прошивку.

Поток:

1. Оператор в UI создаёт новую запись прошивки и загружает бинарник.
2. Backend сохраняет файл (например, в `storage/app/firmware/`) и создаёт запись в таблице `firmware_images`.
3. Python-сервис получает сигнал (webhook/endpoint), что доступна новая версия.
4. Python-сервис публикует команду OTA в MQTT для выбранных узлов.
5. Узел ESP32:
 - получает команду;
 - скачивает бинарник по HTTPS/HTTP с backend;
 - выполняет OTA;
 - отправляет результат через MQTT.

---

## 2. Идентификаторы прошивок

Таблица `firmware_images` (пример):

- `id` — PK;
- `uid` — человекочитаемый идентификатор (например, `esp32-ph-v1.0.3`);
- `node_type` — тип узла (`ph`, `ec`, `climate`, `light`, `irrig`);
- `version` — семантическая версия (`1.0.3`);
- `file_path` — путь до бинарника;
- `checksum_sha256` — контрольная сумма;
- `created_at`, `updated_at`.

Узел хранит у себя:

- `firmware_version` (строка);
- `firmware_uid` (опционально);
- `last_update_at`.

---

## 3. MQTT-команда OTA

Используется системный топик:

```text
hydro/system/ota/{node_uid}
```

Payload (пример):

```json
{
 "cmd": "OTA_UPDATE",
 "firmware_uid": "esp32-ph-v1.0.3",
 "file_url": "https://backend/firmware/esp32-ph-v1.0.3.bin",
 "checksum_sha256": "abc123 ",
 "ttl_ms": 600000,
 "request_id": "ota-2025-01-01-12-00-00-001"
}
```

Требования:

- Узел обязан проверить:
 - TTL команды;
 - корректность формата URL;
 - контрольную сумму после загрузки.

---

## 4. Поведение узла ESP32

1. Получить команду из `hydro/system/ota/{node_uid}`.
2. Проверить `ttl_ms` и другие поля.
3. Скачать файл по `file_url` (HTTPS/HTTP, размер ограничен).
4. Подсчитать SHA-256 и сравнить с `checksum_sha256`.
5. Если всё хорошо:
 - выполнить OTA-обновление;
 - сохранить новую версию в NVS;
 - отправить статус:

```text
hydro/system/ota/{node_uid}/status
```

```json
{
 "request_id": "ota-2025-01-01-12-00-00-001",
 "status": "OK",
 "old_version": "1.0.2",
 "new_version": "1.0.3",
 "ts": 1737355604000
}
```

6. Если ошибка:
 - не обновляться;
 - отправить статус с ошибкой и кодом причины.

---

## 5. Backend / Python-логика

- Backend:
 - хранит прошивки и их метаданные;
 - предоставляет защищённые URL для скачивания;
 - ведёт историю обновлений по узлам.
- Python-сервис:
 - по запросу оператора или плану обновлений:
 - формирует список узлов для OTA;
 - отправляет MQTT-команды;
 - слушает `status`-топики и обновляет БД.

---

## 6. Правила для ИИ-агентов

1. Не менять формат базовой MQTT-команды OTA без обновления этого документа.
2. Не заставлять узлы скачивать прошивки из непроверенных источников.
3. Не добавлять тяжёлую логику в код ESP32, связанную с управлением версиями — всё это на стороне backend/Python.

OTA в этой системе — **управляемый, централизованный процесс**, а не хаотичное обновление «по месту».
