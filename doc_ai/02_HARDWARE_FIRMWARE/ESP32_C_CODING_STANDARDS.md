# ESP32_C_CODING_STANDARDS.md
# Стандарты написания прошивки на C под ESP32 (ESP-IDF)
# Стиль кода • Архитектура модулей • Ошибки • Логи • Тестируемость

Документ задаёт единый стиль и архитектурные правила для прошивок узлов 2.0
на ESP32 (ESP-IDF, C).

Он обязателен для:
- людей-разработчиков прошивки,
- ИИ-агентов, генерирующих/рефакторящих код.

---

## 1. Общие принципы

1. Язык: **C (C99)**. C++ в прошивке запрещён.
2. Фреймворк: **ESP-IDF 5.x**.
3. Каждый узел — отдельный ESP-IDF проект с:
 - `main/` для высокоуровневой логики,
 - `components/` для переиспользуемых модулей.
4. Все hardware-зависимые детали изолируются в отдельных компонентах
 (драйверы, HAL).
5. Код пишется «от задач/сервисов», а не «от main».

---

## 2. Структура файлов и модулей

Рекомендуемая структура:

- `main/main.c`
 - точка входа;
 - инициализация: NVS, логгирование, wifi_engine, mqtt_engine, ui, sensors, watchdog;
 - создание основных FreeRTOS-задач.

- `components/`:
 - `hw_i2c/` — общий драйвер/обёртка над I²C с mutex’ом;
 - `hw_gpio/` — общие GPIO-утилиты;
 - `sensors_ph/`, `sensors_ec/`, `sensors_climate/` — драйверы сенсоров;
 - `node_config/` — работа с NVS и конфигом ноды;
 - `wifi_engine/` — реализация Wi-Fi state machine;
 - `mqtt_engine/` — MQTT-клиент и топик-роутер;
 - `ui_oled/` — локальный UI (см. `NODE_OLED_UI_SPEC.md`);
 - `input_controls/` — кнопки/энкодер (см. `NODE_INPUT_CONTROLS.md`);
 - `diag/` — диагностика, метрики, watchdog-хуки.

Каждый компонент должен иметь:

- `include/<component_name>.h` — публичный API;
- `<component_name>.c` — реализацию.

---

## 3. Стиль кода

### 3.1. Именование

- Функции: `snake_case`, префикс компонента:
 - `wifi_engine_init()`, `wifi_engine_start()`;
 - `ui_oled_set_state()`.
- Типы: `snake_case + _t`:
 - `wifi_state_t`, `ui_state_t`.
- Глобальные переменные: избегаем; если нужно — префикс модуля и `static` в .c.
- Макросы: `UPPER_SNAKE_CASE`.

### 3.2. Форматирование

- Отступ: 4 пробела, табуляции не используем.
- Одна инструкция на строку.
- Фигурные скобки:
 - открывающая на той же строке, `K&R` стиль.

Пример:

```c
if (err != ESP_OK) {
 ESP_LOGE(TAG, "Failed to init wifi: %s", esp_err_to_name(err));
 return err;
}
```

---

## 4. Обработка ошибок

Стандарт: **никаких тихих провалов**.

- Любая функция, которая может вернуть ошибку, должна:
 - иметь тип `esp_err_t` или собственный enum ошибок,
 - логировать ошибку с понятным контекстом.

Шаблоны:

```c
esp_err_t wifi_engine_init(void)
{
 esp_err_t err = esp_wifi_init(&cfg);
 if (err != ESP_OK) {
 ESP_LOGE(TAG, "esp_wifi_init failed: %s", esp_err_to_name(err));
 return err;
 }
 // дополнительные шаги по инициализации и проверкам Wi‑Fi
 return ESP_OK;
}
```

Допустимо использовать обёртку над `ESP_ERROR_CHECK`, например:

```c
#define CHECK_OK(x) do { esp_err_t __err = (x); if (__err != ESP_OK) { ESP_LOGE(TAG, "%s failed: %s", #x, esp_err_to_name(__err)); return __err; } } while (0)
```

---

## 5. Логирование

Для каждого компонента:

```c
static const char *TAG = "wifi_engine";
```

Уровни логов:

- `ESP_LOGE` — ошибки, приводящие к деградации функции;
- `ESP_LOGW` — потенциальные проблемы (повторы коннекта, нестабильный RSSI);
- `ESP_LOGI` — ключевые состояния (подключились к Wi-Fi, MQTT, начали калибровку);
- `ESP_LOGD` — подробности для отладки (пакеты, промежуточные значения);
- `ESP_LOGV` — очень подробный вывод, по умолчанию выключен.

Запрещено логировать:

- пароли и чувствительные данные (Wi-Fi пароль, токены, ключи).

---

## 6. FreeRTOS: задачи, очереди, mutex’ы

### 6.1. Задачи

Каждый логический «сервис» должен быть оформлен отдельной задачей:

- `wifi_task`
- `mqtt_task`
- `sensor_task`
- `ui_task`
- `input_task`
- `diag_task` (опционально)

Правила:

- приоритеты: сеть > критические измерения > UI > фоновые задачи;
- стек каждой задачи должен быть явно задан и проверен в отладке;
- нельзя создавать задачи в цикле/по многу раз без удаления.

### 6.2. Очереди и event groups

- Обмен данными и событиями делать через:
 - `xQueue` (структурированные сообщения),
 - `EventGroup` (флаги состояния).
- Запрещено:
 - использовать глобальные разделяемые структуры без защиты mutex’ом;
 - «пробрасывать» указатели на стековые переменные в другие задачи.

---

## 7. Работа с I²C

- Один общий компонент `hw_i2c`:
 - инициализация шины;
 - `i2c_master_write_read_device()` через обёртки;
 - mutex для сериализации доступа.

Никаких прямых вызовов `i2c_master_*` из разных модулей.

---

## 8. Конфигурация и NVS

Работа с конфигом:
- выносим в `node_config`:
 - чтение/запись Wi-Fi,
 - метаданные узла,
 - калибровочные данные.

Любой код, который лезет в NVS, должен проходить через этот компонент.

---

## 9. Unit-тестируемость

Компоненты должны быть написаны так, чтобы:

- их можно было вызывать из `idf.py unit-test` (где это разумно);
- бизнес-логика (например, фильтрация измерений, state machine) максимально не зависела от железа — через интерфейсы/колбэки.

---

## 10. Требования к ИИ-агенту

1. Использовать только C и ESP-IDF API.
2. Не добавлять глобальные переменные без крайней необходимости.
3. Все новые компоненты:
 - кладутся в `components/`,
 - получают чётко описанный `include/*.h` API.
4. Любой новый код должен:
 - возвращать ошибки вместо `abort()`/`ESP_ERROR_CHECK` там, где это возможно;
 - логировать контекст ошибки.