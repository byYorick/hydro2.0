# DEV_TASKS_FOR_AI_ASSISTANTS_SPEC.md
# Спецификация: как разработчику давать задания ИИ-ассистентам в Hydro 2.0

Этот документ описывает правила для **разработчиков**: как правильно формулировать задачи
для ИИ-ассистентов (ChatGPT и других моделей), работающих над проектом Hydro 2.0.

Он дополняет:

- `TASKS_FOR_AI_AGENTS.md` — общий гайд по структуре задач.
- `OPERATOR_TASKS_FOR_AI_SPEC.md` — как оператору теплицы говорить с ИИ.
- `DEV_CONVENTIONS.md` — общие правила разработки.
- Архитектурные документы в `01_SYSTEM`, `02_HARDWARE_FIRMWARE`, `03_TRANSPORT_MQTT`, `04_BACKEND_CORE`, `09_AI_AND_DIGITAL_TWIN`, `10_AI_DEV_GUIDES`.

Здесь — практический “бойовой” стандарт: **как разработчик должен ставить задачи ИИ так, чтобы
результат можно было сразу коммитить в репозиторий**, а не переписывать с нуля.

---

## 1. Роли ИИ-ассистентов в проекте

В Hydro 2.0 предполагаются несколько типов задач для ИИ:

1. **Codegen** — генерация нового кода:
   - модули прошивки (ESP32 / C / ESP-IDF),
   - backend-модули (API, workers),
   - Android-клиент, утилиты.

2. **Refactor** — рефакторинг существующего кода:
   - разбиение “божественных” модулей,
   - приведение к конвенциям,
   - упрощение логики.

3. **Spec & Docs** — документация и спецификации:
   - заполнение `.md` файлов,
   - генерация протоколов, описаний интерфейсов.

4. **Review & Audit** — ревью и анализ:
   - поиск ошибок,
   - поиск несоответствий с архитектурой,
   - предложения по улучшению.

5. **Glue & Integration** — склеивание слоёв:
   - прошивка ↔ MQTT ↔ backend ↔ frontend,
   - проверка целостности контрактов.

Для каждого типа задач важно **заранее выбрать роль ИИ** и явно прописать её в задаче:
“как Codegen-ассистент”, “как Reviewer-ассистент” и т.п.

---

## 2. Базовые принципы для разработчика

1. **Никогда не проси ИИ “придумать архитектуру заново”**  
   Всегда опирайся на уже существующие `.md` в репозитории.

2. **Всегда указывай источники правды**  
   Для любой нетривиальной задачи прямо перечисли:
   - какие `.md` использовать;
   - какие `.c/.h` файлы нужно читать/изменять.

3. **Задача должна быть “слишком конкретной”**  
   Лучше перебор с деталями, чем “сделай красиво”.

4. **Один ассистент — одна роль**  
   Если нужно сгенерировать код и потом его отревьюить — это две задачи и лучше два ассистента
   (Codegen и Reviewer).

5. **Всегда задавай формат ответа**  
   Чтобы код можно было сразу копировать в файлы:
   - с указанием `// path: ...`,
   - без лишнего текста внутри кодовых блоков,
   - без “примеров кода” — только финальная версия.

---

## 3. Структура задачи для ИИ (для разработчика)

Любая задача разработчика ИИ-ассистенту должна содержать:

1. **Название задачи**
2. **Роль ассистента**
3. **Контекст**
4. **Текущая ситуация**
5. **Цель**
6. **Артефакты (входные файлы / спеки)**
7. **Ограничения**
8. **Ожидаемый результат**
9. **Формат ответа**

### 3.1. Поля подробнее

#### 1) Название задачи

Кратко, технично. Примеры:

- “Реализация драйвера INA209 и pump_safety для ноды насосов”
- “Рефакторинг модуля mqtt_client_node_common”
- “Заполнение спецификации NODE_OLED_UI_SPEC.md для pH-ноды”

#### 2) Роль ассистента

Примеры:

- “Ты выступаешь как Codegen-ассистент прошивок ESP32 (C, ESP-IDF).”
- “Ты выступаешь как Reviewer-ассистент и не пишешь новый код, только проверки и замечания.”

#### 3) Контекст

Обязательно:

- слой системы (узел, backend, Android и т.д.);
- какие `.md` описывают архитектуру;
- какие решения уже приняты (например: один INA209 на ноду, общая шина насосов).

#### 4) Текущая ситуация

Кратко: что уже есть и что не устраивает.

Пример:

- “Сейчас в `node_pump` нет драйвера INA209. Логика команд к насосам описана только на уровне
   протокола в `NODE_LOGIC_FULL.md` и `DEVICE_NODE_PROTOCOL.md`.”

#### 5) Цель

Чётко: как должен измениться код/репозиторий после задачи.

Пример:

- “Хотим получить рабочий драйвер INA209 и модуль pump_safety так, чтобы:
   - при командах к насосам измерять суммарный ток по шине,
   - сравнивать его с порогами,
   - формировать `command_response` с `ACK`/`ERROR`.”

#### 6) Артефакты (входные файлы / спеки)

Явный список файлов и документов:

- `02_HARDWARE_FIRMWARE/HARDWARE_ARCH_FULL.md` (раздел 8.2)
- `02_HARDWARE_FIRMWARE/NODE_LOGIC_FULL.md` (раздел 4.2.1)
- `02_HARDWARE_FIRMWARE/DEVICE_NODE_PROTOCOL.md` (раздел об актуации и INA209)
- `02_HARDWARE_FIRMWARE/NODE_CHANNELS_REFERENCE.md` (pump_* и pump_bus_current)
- `03_TRANSPORT_MQTT/MQTT_SPEC_FULL.md` (Command Response)
- `DEV_CONVENTIONS.md`, `TASKS_FOR_AI_AGENTS.md`

Если есть существующие `.c/.h`, нужно:

- указать путь,
- коротко описать, что там есть.

#### 7) Ограничения

Примеры ограничений:

- “Соблюдать `DEV_CONVENTIONS.md`.”
- “Не использовать динамическую память в обработчике команд.”
- “Не менять публичный интерфейс `mqtt_client_node_common.h`.”
- “Не использовать C++.”

#### 8) Ожидаемый результат

Максимально конкретно:

- какие файлы будут созданы;
- какие файлы будут изменены;
- какие функции / структуры должны существовать.

#### 9) Формат ответа

Пример стандарта:

1. Краткое резюме (что сделано, какие файлы).
2. Полные тексты файлов с указанием пути:

   ```c
   // path: node_pump/drivers/ina209_driver.h
   ...код...
   ```

   ```c
   // path: node_pump/drivers/ina209_driver.c
   ...код...
   ```

3. Если что-то осталось за рамками — краткий список TODO.

---

## 4. Типовые шаблоны задач для разработчика

Ниже — готовые шаблоны, которые можно копировать и адаптировать под конкретную задачу.

### 4.1. Codegen: новый модуль прошивки

```markdown
# Задача: <кратко — новый модуль прошивки>

## Роль ассистента

Ты выступаешь как Codegen-ассистент для прошивки ESP32 (C, ESP-IDF, FreeRTOS).
Не придумывай архитектуру заново, опирайся на существующие `.md` и конвенции проекта.

## Контекст

- Компонент: прошивка ноды <название> (например, насосы/pH/EC/климат).
- Архитектура ноды: см. `02_HARDWARE_FIRMWARE/NODE_ARCH_FULL.md`.
- Логика: см. `NODE_LOGIC_FULL.md`.
- Протокол и команды: см. `DEVICE_NODE_PROTOCOL.md`.
- Каналы: см. `NODE_CHANNELS_REFERENCE.md`.
- MQTT: см. `03_TRANSPORT_MQTT/MQTT_SPEC_FULL.md`.
- Конвенции: `DEV_CONVENTIONS.md`, `ESP32_C_CODING_STANDARDS.md`.

## Текущая ситуация

- Сейчас <описать, что есть / чего нет>.
- Нужен новый модуль: `<кратко>`.

## Цель

Реализовать модуль, который:
- `<пункт 1>`
- `<пункт 2>`
- `<пункт 3>`

## Входные файлы и спеки

- `...` (список .md)
- `...` (список .c/.h, если relevant)

## Ограничения

- Соблюдать `DEV_CONVENTIONS.md`.
- Не использовать динамическую память в “горячем” пути.
- Не менять публичный API существующих модулей, если не указано обратное.

## Ожидаемый результат

- Новый файл: `path/to/new_module.c`
- Новый файл: `path/to/new_module.h`
- При необходимости — изменения в: `path/to/existing.c`

## Формат ответа

1. Краткое резюме.
2. Полный код файлов в блоках с указанием `// path: ...`.
3. Краткий список возможных дальнейших улучшений (TODO), без заглушек в коде.
```

### 4.2. Refactor: изменение существующего модуля

```markdown
# Задача: рефакторинг модуля <имя файла>

## Роль ассистента

Ты выступаешь как Refactor-ассистент.  
Твоя задача — улучшить существующий код без изменения внешнего поведения
(кроме явно оговорённых изменений).

## Контекст

- Файл: `path/to/file.c`
- Назначение модуля: <кратко>.
- Архитектура: см. `<список .md>`.
- Проблемы:
  - `<проблема 1>`
  - `<проблема 2>`

## Цель

- Упростить код.
- Разбить на логичные функции/модули.
- Привести к `DEV_CONVENTIONS.md`.

## Ограничения

- Публичный API (`.h`) оставляем совместимым, если явно не указано иное.
- Не менять формат сообщений/структур, если не описано в задаче.

## Ожидаемый результат

- Обновлённый полный файл `path/to/file.c`.
- При необходимости — обновлённый `path/to/file.h`.

## Формат ответа

- Краткое резюме.
- Полный код файла(ов) с указанием `// path: ...`.
```

### 4.3. Spec & Docs: заполнение/расширение .md

```markdown
# Задача: дополнить спецификацию <название документа>

## Роль ассистента

Ты выступаешь как Spec-ассистент.  
Твоя задача — дописать техническую спецификацию без маркетинговых фраз и общих слов.

## Контекст

- Документ: `path/to/doc.md`.
- Связанные документы:
  - `...`
- Архитектура и протоколы уже заданы, нельзя их противоречить.

## Текущая ситуация

- В документе не хватает:
  - `<раздел 1>`
  - `<раздел 2>`

## Цель

- Заполнить указанные разделы так, чтобы:
  - разработчик мог по ним писать код без вопросов;
  - ИИ-ассистент мог по ним ориентироваться в архитектуре.

## Ограничения

- Не использовать заглушки и “потом дописать”.
- Писать строго технически.

## Ожидаемый результат

- Полный обновлённый текст файла `path/to/doc.md`.

## Формат ответа

- Только обновлённый текст файла.
```

### 4.4. Review & Audit: проверка кода или спеки

```markdown
# Задача: ревью модуля <имя>

## Роль ассистента

Ты выступаешь как Reviewer-ассистент.  
Не пишешь новый код, только анализируешь существующий и даёшь рекомендации.

## Контекст

- Файлы:
  - `path/to/file1.c`
  - `path/to/file2.h`
- Архитектура/спеки:
  - `...`

## Цель

- Найти:
  - нарушения `DEV_CONVENTIONS.md`;
  - потенциальные баги;
  - расхождения с архитектурой и протоколами.

## Ожидаемый результат

Краткий отчёт:

1. Список проблем с указанием строк/фрагментов.
2. Рекомендации по исправлению (без полного переписывания файла).
3. Выявленные несоответствия с `.md`-спеками (если есть).
```

---

## 5. Мини-чеклист для разработчика перед отправкой задачи ИИ

1. Указаны ли **файлы и `.md`**, на которые нужно опираться?
2. Понятно ли, **что именно** должен сделать ассистент (роль, цель)?
3. Прописаны ли **ограничения** (что нельзя менять, какие стандарты соблюдать)?
4. Описан ли **формат ответа**, пригодный для прямой интеграции в репозиторий?
5. Разбита ли большая задача на несколько логичных подзадач?

Если ответы “да” — задача ИИ-ассистенту сформулирована правильно.
