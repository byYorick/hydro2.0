# E32: Out of Order Guard - client-side reconciliation по event_id
# DoD: проверка, что client-side reconciliation по event_id корректен (не принимает старое)

name: E32_out_of_order_guard
description: |
  Проверяет защиту от out-of-order событий:
  - Получаем snapshot с last_event_id
  - Пытаемся запросить события с after_id меньше last_event_id
  - Проверяем, что система не возвращает старые события (или возвращает корректно)
  - Проверяем, что события возвращаются в правильном порядке

setup:
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1884}
        username: ${MQTT_USER:-null}
        password: ${MQTT_PASS:-null}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured
        channels:
          - ph_sensor
        actuators:
          - main_pump
      telemetry:
        interval_seconds: 2.0
        heartbeat_interval_seconds: 15.0
  prerequisites:
    - database: zones table exists
    - database: zone_events table exists
    - backend: Laravel is running

actions:
  - step: set_test_uids
    type: set
    test_node_uid: ${setup.node_sim.config.node.node_uid}

  - step: fetch_node_id
    type: database_query
    query: |
      SELECT id AS node_id, zone_id
      FROM nodes
      WHERE uid = :node_uid
      LIMIT 1
    params:
      node_uid: ${test_node_uid}
    save: node_row

  - step: get_zones
    type: api_get
    endpoint: /api/zones
    save: zones_response

  - step: set_zone_id
    type: set
    zone_id: ${node_row.0.zone_id}

  # Получаем snapshot для определения last_event_id
  - step: get_snapshot
    type: api_get
    endpoint: /api/zones/${zone_id}/snapshot
    save: snapshot_response

  - step: set_last_event_id
    type: set
    last_event_id: ${snapshot_response.data.last_event_id}

  # Создаем новое событие (например, через отправку команды)
  - step: get_nodes
    type: api_get
    endpoint: /api/nodes
    save: nodes_response

  - step: set_node_id
    type: set
    test_node_id: ${node_row.0.node_id}

  # Отправляем команду для создания zone_event
  - step: send_command_to_create_event
    type: api_post
    endpoint: /api/nodes/${test_node_id}/commands
    payload:
      cmd: set_relay
      channel: main_pump
      params:
        state: false
    save: command_response
    optional: true  # Может вернуть 503 если bridge недоступен

  # Альтернативно: создаем событие напрямую в БД
  - step: create_event_manually_if_needed
    type: database_query
    query: |
      INSERT INTO zone_events (zone_id, type, entity_type, entity_id, payload_json, created_at)
      VALUES (:zone_id, 'COMMAND_SENT', 'command', 'test-cmd-' || :timestamp, '{"cmd": "set_relay", "channel": "main_pump"}'::jsonb, NOW())
      RETURNING id
    params:
      zone_id: ${zone_id}
      timestamp: ${TIMESTAMP_S}
    save: manual_event
    condition: ${!command_response || command_response.status == 'error'}

  - step: wait_after_command
    type: sleep
    seconds: 2

  # Ждем появления нового события в zone_events
  - step: wait_for_new_event
    type: sleep
    seconds: 3

  - step: set_new_last_event_id
    type: set
    new_last_event_id: ${last_event_id}

  # Запрашиваем события с after_id
  # Система должна вернуть только события после указанного after_id
  - step: get_events_after_old_id
    type: api_get
    endpoint: /api/zones/${zone_id}/events
    params:
      after_id: ${last_event_id}
    save: events_response

  - step: wait_processing
    type: sleep
    seconds: 1

assertions:
  # Проверка 1: События получены
  - name: events_received
    type: json_assertion
    data: ${events_response}
    expected:
      - field: data
        operator: is_type
        value: list
        optional: true

  # Проверка 2: Zone существует
  - name: zone_exists
    type: database_query
    query: |
      SELECT id
      FROM zones
      WHERE id = :zone_id
    params:
      zone_id: ${zone_id}
    expected_rows: 1

