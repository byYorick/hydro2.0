name: E31_reconnect_replay_gap
description: |
  Проверяет механизм "snapshot + replay" для восстановления клиента после разрыва WS:
  - Берём snapshot (last_event_id)
  - "Теряем" WS (disconnect)
  - Создаём событие (через MQTT error → alert → zone_event)
  - Переподключаемся
  - Делаем replay через GET /api/zones/{zone}/events?after_id=...

setup:
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1884}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured

actions:
  - step: start_node_simulator
    type: start_simulator
    config_ref: node_sim.config
    wait_seconds: 2
    optional: true  # node-sim уже может быть запущен

  - step: get_zone_id
    type: api_get
    endpoint: /api/zones
    save: zones_response

  - step: set_zone_id
    type: set
    zone_id: ${zones_response.data.data[0].id}

  - step: connect_ws
    type: websocket_connect

  - step: wait_after_connect
    type: sleep
    seconds: 1

  - step: subscribe_ws_zone
    type: websocket_subscribe
    channel: "private-hydro.zones.${zone_id}"

  - step: wait_after_subscribe
    type: sleep
    seconds: 1

  - step: fetch_snapshot_before
    type: api_get
    endpoint: /api/zones/${zone_id}/snapshot
    save: snapshot_before

  - step: capture_last_event_id
    type: set
    last_event_id_before: ${snapshot_before.data.last_event_id}

  - step: disconnect_ws
    type: websocket_disconnect

  - step: wait_after_disconnect
    type: sleep
    seconds: 1

  # Создаём событие во время "gap" (через error → alert → zone_event)
  - step: publish_error_during_gap
    type: mqtt_publish
    topic: "hydro/gh-test-1/zn-test-1/nd-ph-esp32una/error"
    payload:
      level: "ERROR"
      component: "sensor"
      error_code: "infra_sensor_stuck_i2c"
      message: "I2C sensor bus stuck (gap)"
      ts: ${TIMESTAMP_MS}
    qos: 1
    wait_seconds: 5  # Увеличиваем время для обработки ошибки и создания алерта/события

  - step: reconnect_ws
    type: websocket_connect

  - step: wait_after_reconnect
    type: sleep
    seconds: 1

  - step: fetch_events_after_id
    type: api_get
    endpoint: /api/zones/${zone_id}/events
    params:
      after_id: ${last_event_id_before}
      limit: 50
    save: events_after

  - step: wait_after_replay
    type: sleep
    seconds: 2

assertions:
  # Проверка: snapshot содержит last_event_id (DoD требует проверку last_event_id)
  # Примечание: last_event_id может быть null если зона новая и событий еще нет
  - name: snapshot_has_last_event_id
    type: json_assertion
    source: snapshot_before
    path: data.last_event_id
    expected:
      - field: value
        operator: is_not_null
    optional: true  # last_event_id может быть null для новой зоны

  # Проверка: replay возвращает события после last_event_id (DoD требует валидацию gap)
  - name: replay_returns_events_after_gap
    type: json_assertion
    data: ${events_after}
    expected:
      - field: data
        operator: is_type
        value: list

  # Проверка: все события в replay имеют event_id больше last_event_id из snapshot
  # Примечание: если last_event_id был null, проверяем что события вообще есть
  - name: validate_replay_gap
    type: compare_json
    source1: snapshot_before
    path1: data.last_event_id
    source2: events_after
    path2: data[0].id
    operator: less_than
    # Если событий нет или last_event_id был null, это тоже валидный случай (gap пустой)
    optional: true

cleanup:
  - step: disconnect_ws_final
    type: websocket_disconnect
  - step: stop_node_simulator
    type: stop_simulator
    optional: true  # fault injection не работает в контейнере
