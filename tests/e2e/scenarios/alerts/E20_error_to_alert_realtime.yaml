# E04: Error Alert - Ошибка → alert ACTIVE + WS + dedup
# DoD: error → alert ACTIVE + WS + dedup

name: E04_error_alert
description: |
  Проверяет создание алерта при ошибке:
  - Узел публикует ошибку через MQTT
  - Алерт создается в БД со статусом ACTIVE
  - WebSocket событие отправляется на канал зоны
  - Повторные одинаковые ошибки не создают дубликаты алертов (dedup)

setup:
  # Настройка симулятора узла
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1883}
        username: ${MQTT_USER:-null}
        password: ${MQTT_PASS:-null}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured
        channels:
          - ph_sensor
        actuators:
          - main_pump
      telemetry:
        interval_seconds: 2.0
        heartbeat_interval_seconds: 15.0

  # Предварительные условия
  prerequisites:
    - database: nodes table exists
    - database: zones table exists with zone_id for zn-test-1
    - database: alerts table exists
    - database: node attached to zone
    - mqtt: broker is accessible
    - backend: Laravel is running
    - websocket: WebSocket server is running

actions:
  # Шаг 1: Получаем zone_id
  - step: get_zones
    type: api_get
    endpoint: "/api/zones"
    save: zones_response
  
  - step: set_zone_id
    type: set
    zone_id: ${zones_response.data.data[0].id}


  # Шаг 2: Запуск симулятора узла
  - step: start_node_simulator
    type: start_simulator
    config_ref: node_sim.config
    wait_seconds: 3

  # Шаг 3: Подписка на WebSocket канал зоны
  - step: subscribe_ws_zone
    type: websocket_subscribe
    channel: "private-hydro.zones.${zone_id}"
    wait_seconds: 1

  # Шаг 4: Узел публикует ошибку (первый раз)
  - step: node_publishes_error
    type: mqtt_publish
    topic: "hydro/gh-test-1/zn-test-1/nd-ph-esp32una/error"
    payload:
      level: "ERROR"
      component: "sensor"
      error_code: "infra_sensor_stuck_i2c"
      message: "I2C sensor bus stuck"
      ts: ${TIMESTAMP_MS}
    qos: 1
    wait_seconds: 5  # Увеличиваем время ожидания обработки

  # Шаг 5: Узел публикует ту же ошибку повторно (для проверки dedup)
  - step: node_publishes_error_duplicate
    type: mqtt_publish
    topic: "hydro/gh-test-1/zn-test-1/nd-ph-esp32una/error"
    payload:
      level: "ERROR"
      component: "sensor"
      error_code: "infra_sensor_stuck_i2c"
      message: "I2C sensor bus stuck"
      ts: ${TIMESTAMP_MS}
    qos: 1
    wait_seconds: 5  # Увеличиваем время ожидания обработки

assertions:
  # Проверка 1: Алерт создан в БД со статусом ACTIVE
  # Примечание: Код алерта может отличаться от error_code в MQTT сообщении
  # Баг с отсутствием error_count исправлен - код теперь обрабатывает отсутствие колонок gracefully
  # Используем database_query - он сам ждет через db.wait внутри, если указан timeout
  # Экранируем % в LIKE паттернах как %%
  - name: alert_created_active
    type: database_query
    query: |
      SELECT id, status, code, type, zone_id, created_at
      FROM alerts
      WHERE zone_id = :zone_id
      AND status = 'ACTIVE'
      AND (code LIKE '%%infra_sensor_stuck_i2c%%' OR code LIKE '%%sensor%%stuck%%' OR code LIKE '%%node_error%%')
      ORDER BY created_at DESC
      LIMIT 1
    params:
      zone_id: ${zone_id}
    timeout: 20.0
    expected_rows: 1
    expected:
      - field: status
        operator: equals
        value: "ACTIVE"

  # Проверка 2: Алерт существует (dedup может не работать для разных error_code, проверяем что хотя бы один создан)
  - name: alert_exists
    type: database_query
    query: |
      SELECT COUNT(*) as alert_count
      FROM alerts
      WHERE zone_id = :zone_id
      AND (code LIKE '%%infra_sensor_stuck_i2c%%' OR code LIKE '%%sensor%%stuck%%' OR code LIKE '%%node_error%%')
      AND status = 'ACTIVE'
    params:
      zone_id: ${zone_id}
    expected:
      - field: alert_count
        operator: greater_than_or_equal
        value: 1

cleanup:
  - step: stop_node_simulator
    type: stop_simulator
