# E14: Command Response Before Sent - Быстрый response, stub/UPSERT
# DoD: симулировать "быстрый response", убедиться: stub/UPSERT не ломает финал

name: E14_command_response_before_sent
description: |
  Проверяет обработку быстрого ответа от узла:
  - Узел отвечает на команду до того, как она была помечена как SENT
  - Система должна корректно обработать такой ответ (stub/UPSERT)
  - Финальный статус команды остается корректным

setup:
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1884}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured
        channels:
          - ph_sensor
        actuators:
          - main_pump
      telemetry:
        interval_seconds: 2.0
        heartbeat_interval_seconds: 15.0

actions:
  - step: start_node_simulator
    type: start_simulator
    config_ref: node_sim.config
    wait_seconds: 3
    optional: true  # node-sim уже может быть запущен

  - step: get_zones
    type: api_get
    endpoint: /api/zones
    save: zones_response

  - step: get_nodes
    type: api_get
    endpoint: /api/nodes
    save: nodes_response

  - step: set_zone_and_node
    type: set
    test_zone_id: ${zones_response.data.data[0].id}
    test_node_id: ${nodes_response.data.data[0].id}

  - step: subscribe_zone_channel
    type: websocket_subscribe
    channel: hydro.zones.1

  # Симулируем быстрый ответ: публикуем command_response через MQTT сразу после отправки команды
  # Это создает race condition, где response может прийти до обновления статуса на SENT
  - step: send_command
    type: api_post
    endpoint: /api/nodes/1/commands
    payload:
      cmd: set_relay_state
      channel: main_pump
      params:
        state: true
    save: command_response
    optional: true  # Может вернуть 503 если bridge недоступен

  - step: set_command_id_from_response
    type: set
    command_id: ${command_response.data.command_id}
    condition: ${command_response && command_response.data && command_response.data.command_id}

  # Если команда не была создана из-за 503, создаем команду вручную для теста
  - step: create_command_manually_if_needed
    type: database_query
    query: |
      INSERT INTO commands (zone_id, node_id, cmd, channel, params, status, source, cmd_id, created_at, updated_at)
      VALUES (:zone_id, :node_id, 'set_relay_state', 'main_pump', '{"state": true}'::jsonb, 'QUEUED', 'test', gen_random_uuid()::text, NOW(), NOW())
      RETURNING cmd_id
    params:
      zone_id: 1
      node_id: 1
    save: manual_command
    condition: ${!command_id || command_id == '' || command_id == null}

  - step: set_command_id_from_manual
    type: set
    command_id: ${manual_command[0].cmd_id}
    condition: ${manual_command && len(manual_command) > 0 && manual_command[0].cmd_id}

  # Сразу после отправки команды отправляем response через MQTT (симулируем быстрый ответ)
  - step: publish_fast_response
    type: mqtt_publish
    topic: hydro/gh-test-1/zn-test-1/nd-ph-esp32una/main_pump/command_response
    payload:
      cmd_id: ${command_id}
      status: ACK
      ts: ${TIMESTAMP_MS}
    qos: 1
    wait_seconds: 1

  # Далее отправляем DONE
  - step: publish_done_response
    type: mqtt_publish
    topic: hydro/gh-test-1/zn-test-1/nd-ph-esp32una/main_pump/command_response
    payload:
      cmd_id: ${command_id}
      status: DONE
      ts: ${TIMESTAMP_MS}
    qos: 1

  - step: wait_after_second_response
    type: sleep
    seconds: 2

  # Проверяем, что финальный статус корректен (не нарушен из-за race condition)
  - step: wait_for_final_status
    type: sleep
    seconds: 2

assertions:
  # Проверка: Команда достигает финального статуса DONE (DoD требует проверку финализации)
  # Response before sent не должен ломать систему, но финальный статус должен быть DONE
  - name: final_status_is_done
    type: db.wait
    query: |
      SELECT status
      FROM commands
      WHERE cmd_id = :cmd_id
      AND status = 'DONE'
    params:
      cmd_id: ${command_id}
    timeout: 90.0
    expected_rows: 1
    save: command_status

  # Проверка статуса через database_query (более надежно)
  - name: assert_status_is_done
    type: database_query
    query: |
      SELECT status
      FROM commands
      WHERE cmd_id = :cmd_id
    params:
      cmd_id: ${command_id}
    timeout: 5.0
    expected_rows: 1
    expected:
      - field: status
        operator: equals
        value: "DONE"

  - name: no_status_corruption
    type: database_query
    query: |
      SELECT COUNT(*) as error_count
      FROM commands
      WHERE cmd_id = :cmd_id
      AND status NOT IN ('QUEUED', 'SENT', 'ACK', 'ACCEPTED', 'DONE', 'FAILED', 'TIMEOUT')
    params:
      cmd_id: ${command_id}
    expected:
      - field: error_count
        operator: equals
        value: 0

cleanup:
  - step: stop_node_simulator
    type: stop_simulator
    optional: true  # fault injection не работает в контейнере


