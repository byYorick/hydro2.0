# E61: Fail Closed Corrections - stale telemetry → AE НЕ дозирует
# DoD: stale telemetry ph/ec → AE НЕ дозирует, создает событие/alert "skipped"

name: E61_fail_closed_corrections
description: |
  Проверяет fail-closed поведение при stale telemetry:
  - Публикуется stale telemetry ph/ec (старая временная метка)
  - AE НЕ дозирует (fail-closed)
  - Создается событие/alert "skipped"

setup:
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1884}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured
        channels:
          - ph_sensor
          - ec_sensor
      telemetry:
        # Подавляем авто-телеметрию, чтобы последняя запись оставалась устаревшей
        interval_seconds: 300.0

actions:
  - step: stop_node_simulator_initial
    type: stop_simulator
    wait_seconds: 5

  - step: set_test_uids
    type: set
    test_gh_uid: ${setup.node_sim.config.node.gh_uid}
    test_zone_uid: ${setup.node_sim.config.node.zone_uid}
    test_node_uid: ${setup.node_sim.config.node.node_uid}

  # Получаем зону с UID zn-test-1 из seeder
  - step: get_automation_zone
    type: api_get
    endpoint: /api/zones
    save: zones_response

  - step: set_zone_id_from_uid
    type: database_query
    query: |
      SELECT id
      FROM zones
      WHERE uid = :zone_uid
      LIMIT 1
    params:
      zone_uid: ${test_zone_uid}
    save: zone_row
  
  - step: set_zone_id
    type: set
    zone_id: ${zone_row.0.id}

  - step: cleanup_old_cycles
    type: database_execute
    query: |
      DELETE FROM grow_cycles
      WHERE zone_id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: check_active_cycle
    type: database_query
    query: |
      SELECT id
      FROM grow_cycles
      WHERE zone_id = :zone_id
      AND status IN ('PLANNED', 'RUNNING', 'PAUSED')
      LIMIT 1
    params:
      zone_id: ${zone_id}
    save: active_cycle

  - step: create_plant_if_needed
    type: api_post
    endpoint: /api/plants
    payload:
      name: test-plant-e61-${TIMESTAMP_S}
      scientific_name: Test Plant
    save: plant_response
    condition: ${active_cycle.length == 0}

  - step: create_recipe_if_needed
    type: api_post
    endpoint: /api/recipes
    payload:
      name: test-recipe-e61-${TIMESTAMP_S}
      description: Test recipe for E61
      plant_id: ${plant_response.data.id}
    save: recipe_response
    condition: ${active_cycle.length == 0}

  - step: create_revision_if_needed
    type: api_post
    endpoint: /api/recipes/${recipe_response.data.id}/revisions
    payload:
      description: Test revision for E61
    save: revision_response
    condition: ${active_cycle.length == 0}

  - step: add_phase_if_needed
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/phases
    payload:
      phase_index: 0
      name: Test Phase
      duration_hours: 24
      ph_target: 6.0
      ph_min: 5.8
      ph_max: 6.2
      ec_target: 1.2
      ec_min: 1.0
      ec_max: 1.4
      temp_air_target: 22.0
      humidity_target: 60.0
      irrigation_mode: SUBSTRATE
      irrigation_interval_sec: 3600
      irrigation_duration_sec: 300
    condition: ${active_cycle.length == 0}

  - step: publish_revision_if_needed
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/publish
    payload: {}
    condition: ${active_cycle.length == 0}

  - step: create_cycle_if_needed
    type: api_post
    endpoint: /api/zones/${zone_id}/grow-cycles
    payload:
      recipe_revision_id: ${revision_response.data.id}
      plant_id: ${plant_response.data.id}
      start_immediately: true
    save: cycle_response
    condition: ${active_cycle.length == 0}

  - step: ensure_active_grow_cycle
    type: database_execute
    query: |
      UPDATE grow_cycles
      SET status = 'RUNNING'
      WHERE id = (
        SELECT id
        FROM grow_cycles
        WHERE zone_id = :zone_id
        ORDER BY created_at DESC
        LIMIT 1
      );
    params:
      zone_id: ${zone_id}

  - step: enable_capabilities
    type: database_execute
    query: |
      UPDATE zones
      SET capabilities = jsonb_build_object(
        'ph_control', true,
        'ec_control', true,
        'climate_control', true,
        'light_control', true,
        'irrigation_control', true,
        'recirculation', true,
        'flow_sensor', true
      )
      WHERE id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: wait_after_stop
    type: sleep
    seconds: 5

  - step: compute_stale_ts
    type: database_query
    query: |
      SELECT EXTRACT(EPOCH FROM (NOW() - INTERVAL '10 minutes'))::bigint AS stale_ts
    save: stale_ts_row

  - step: force_stale_telemetry_last
    type: database_execute
    query: |
      UPDATE telemetry_last tl
      SET last_ts = NOW() - INTERVAL '10 minutes',
          updated_at = NOW() - INTERVAL '10 minutes'
      FROM sensors s
      WHERE tl.sensor_id = s.id
        AND s.zone_id = :zone_id
        AND s.type IN ('PH', 'EC');
    params:
      zone_id: ${zone_id}

  # Публикуем stale telemetry (ts в прошлом - больше TELEMETRY_MAX_AGE_MINUTES)
  - step: publish_stale_ph_telemetry
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/ph_sensor/telemetry
    payload:
      metric_type: PH
      value: 6.0
      ts: ${stale_ts_row.0.stale_ts}  # 10 минут назад (stale для E2E с TELEMETRY_MAX_AGE_MINUTES=5)
    qos: 1
    wait_seconds: 2

  - step: publish_stale_ec_telemetry
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/ec_sensor/telemetry
    payload:
      metric_type: EC
      value: 1.2
      ts: ${stale_ts_row.0.stale_ts}  # 10 минут назад
    qos: 1
    wait_seconds: 15  # Даем время AE на обработку

  # Ждем обработки (AE должен обнаружить stale и не дозировать)
  - step: wait_ae_processing
    type: sleep
    seconds: 5

  # Дополнительные stale события для достижения порога алерта
  - step: publish_stale_ph_2
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/ph_sensor/telemetry
    payload:
      metric_type: PH
      value: 6.1
      ts: ${stale_ts_row.0.stale_ts}
    qos: 1
    wait_seconds: 5

  - step: publish_stale_ph_3
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/ph_sensor/telemetry
    payload:
      metric_type: PH
      value: 6.2
      ts: ${stale_ts_row.0.stale_ts}
    qos: 1
    wait_seconds: 15

  # Останавливаем симулятор, чтобы новая свежая телеметрия не перезаписала устаревший ts
  - step: stop_node_simulator_after_stale
    type: stop_simulator
    optional: true

  # Финальный контрольный publish со старыми данными после остановки симулятора
  - step: publish_stale_ph_final
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/ph_sensor/telemetry
    payload:
      metric_type: PH
      value: 6.25
      ts: ${stale_ts_row.0.stale_ts}
    qos: 1
    wait_seconds: 5

  - step: wait_after_final_stale
    type: sleep
    seconds: 15

  - step: force_stale_telemetry_last_final
    type: database_execute
    query: |
      UPDATE telemetry_last tl
      SET last_ts = NOW() - INTERVAL '10 minutes',
          updated_at = NOW() - INTERVAL '10 minutes'
      FROM sensors s
      WHERE tl.sensor_id = s.id
        AND s.zone_id = :zone_id
        AND s.type IN ('PH', 'EC');
    params:
      zone_id: ${zone_id}

  - step: wait_after_final_force
    type: sleep
    seconds: 10

  - step: fetch_freshness_alert
    type: database_query
    query: |
      SELECT id, type, status
      FROM alerts
      WHERE zone_id = :zone_id
      AND type LIKE '%%FRESHNESS%%'
      AND created_at > NOW() - INTERVAL '5 minutes'
      ORDER BY created_at DESC
      LIMIT 1
    params:
      zone_id: ${zone_id}
    save: freshness_alert_rows

assertions:
  # Проверка 1: Команды дозирования НЕ созданы (fail-closed)
  - name: no_dosing_commands
    type: database_query
    query: |
      SELECT COUNT(*) as cmd_count
      FROM commands
      WHERE zone_id = :zone_id
      AND (cmd LIKE '%%ph%%' OR cmd LIKE '%%ec%%' OR cmd LIKE '%%dose%%' OR cmd LIKE '%%correction%%')
      AND created_at > NOW() - INTERVAL '2 minutes'
    params:
      zone_id: ${zone_id}
    expected:
      - field: cmd_count
        operator: equals
        value: 0
    timeout: 10.0

  # Проверка 2: Создан zone_event о пропуске (PH_CORRECTION_SKIPPED_STALE_DATA или CORRECTION_SKIPPED_FRESHNESS_CHECK_FAILED)
  - name: skipped_event_created
    type: database_query
    query: |
      SELECT id, type, details
      FROM zone_events
      WHERE zone_id = :zone_id
      AND (type LIKE '%%SKIP%%' OR type LIKE '%%STALE%%' OR type LIKE '%%FRESHNESS%%')
      AND created_at > NOW() - INTERVAL '2 minutes'
      ORDER BY created_at DESC
      LIMIT 1
    params:
      zone_id: ${zone_id}
    timeout: 10.0
    expected_rows: 1

  # Проверка 3: Alert freshness (создается только после N пропусков подряд)
  - name: freshness_alert_created
    type: custom_assert
    condition: >
      (len(context.get("freshness_alert_rows", [])) == 0) or (
        "FRESHNESS" in (context["freshness_alert_rows"][0].get("type", "")) and
        context["freshness_alert_rows"][0].get("status") is not None
      )

cleanup:
  - step: stop_node_simulator
    type: stop_simulator
    optional: true  # fault injection не работает в контейнере
