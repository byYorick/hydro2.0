# E64: Effective Targets Only - AE reads targets only through effective-targets
# DoD: AE reads targets only through effective-targets

name: E64_effective_targets_only
description: |
  Проверяет, что Automation-engine читает targets только через effective-targets:
  - Recipe targets игнорируются в пользу effective-targets
  - Override targets имеют приоритет над recipe targets
  - Batch updates корректно отражаются в effective-targets

actions:
  - step: get_zones
    type: api_get
    endpoint: /api/zones
    save: zones_response

  - step: set_zone_id
    type: set
    zone_id: ${zones_response.data.data[0].id}

  - step: set_capabilities_without_ph_ec_requirements
    type: database_execute
    query: |
      UPDATE zones
      SET capabilities = jsonb_build_object(
        'ph_control', false,
        'ec_control', false,
        'climate_control', true,
        'light_control', true,
        'irrigation_control', true,
        'recirculation', true,
        'flow_sensor', true
      )
      WHERE id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: ensure_primary_node_online
    type: database_execute
    query: |
      UPDATE nodes
      SET status = 'online',
          last_seen_at = COALESCE(last_seen_at, NOW()),
          updated_at = NOW()
      WHERE zone_id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: ensure_zone_readiness_bindings
    type: database_execute
    query: |
      UPDATE node_channels nc
      SET config = COALESCE(nc.config, '{}'::jsonb) || jsonb_build_object(
        'zone_role',
        CASE
          WHEN nc.channel = 'main_pump' THEN 'main_pump'
          WHEN nc.channel = 'drain_pump' THEN 'drain'
          ELSE nc.config->>'zone_role'
        END
      )
      FROM nodes n
      WHERE n.id = nc.node_id
        AND n.zone_id = :zone_id
        AND nc.channel IN ('main_pump', 'drain_pump');
    params:
      zone_id: ${zone_id}

  - step: ensure_main_and_drain_bindings
    type: database_execute
    query: |
      WITH zone_ctx AS (
        SELECT :zone_id::bigint AS zone_id
      ),
      ensure_instances AS (
        INSERT INTO infrastructure_instances (owner_type, owner_id, asset_type, label, required, created_at, updated_at)
        SELECT 'zone', zc.zone_id, m.asset_type, m.label, true, NOW(), NOW()
        FROM zone_ctx zc
        CROSS JOIN (
          VALUES
            ('PUMP', 'E2E Main Pump'),
            ('DRAIN', 'E2E Drain Pump')
        ) AS m(asset_type, label)
        WHERE NOT EXISTS (
          SELECT 1
          FROM infrastructure_instances ii
          WHERE ii.owner_type = 'zone'
            AND ii.owner_id = zc.zone_id
            AND ii.label = m.label
        )
        RETURNING id
      ),
      upsert_bindings AS (
        INSERT INTO channel_bindings (infrastructure_instance_id, node_channel_id, direction, role, created_at, updated_at)
        SELECT
          ii.id,
          nc.id,
          'actuator',
          m.role,
          NOW(),
          NOW()
        FROM zone_ctx zc
        JOIN nodes n
          ON n.zone_id = zc.zone_id
        JOIN (
          VALUES
            ('main_pump', 'main_pump', 'E2E Main Pump'),
            ('drain_pump', 'drain', 'E2E Drain Pump')
        ) AS m(channel, role, label)
          ON TRUE
        JOIN node_channels nc
          ON nc.node_id = n.id
         AND nc.channel = m.channel
        JOIN infrastructure_instances ii
          ON ii.owner_type = 'zone'
         AND ii.owner_id = zc.zone_id
         AND ii.label = m.label
        ON CONFLICT (node_channel_id) DO UPDATE SET
          infrastructure_instance_id = EXCLUDED.infrastructure_instance_id,
          direction = EXCLUDED.direction,
          role = EXCLUDED.role,
          updated_at = NOW()
        RETURNING node_channel_id
      )
      SELECT 1;
    params:
      zone_id: ${zone_id}

  - step: verify_main_and_drain_bindings_online
    type: db.wait
    query: |
      SELECT cb.role
      FROM channel_bindings cb
      JOIN node_channels nc ON nc.id = cb.node_channel_id
      JOIN nodes n ON n.id = nc.node_id
      WHERE n.zone_id = :zone_id
        AND n.status = 'online'
        AND cb.role IN ('main_pump', 'drain')
      ORDER BY cb.role
    params:
      zone_id: ${zone_id}
    expected_rows: 2
    timeout: 15.0

  - step: cleanup_old_cycles
    type: database_execute
    query: |
      DELETE FROM grow_cycles
      WHERE zone_id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: create_plant
    type: api_post
    endpoint: /api/plants
    payload:
      name: test-plant-e64-${TIMESTAMP_S}
      scientific_name: Test Plant
    save: plant_response

  # Создаем цикл с известными recipe targets
  - step: create_recipe_with_targets
    type: api_post
    endpoint: /api/recipes
    payload:
      name: test-recipe-targets-${TIMESTAMP_S}
      description: Test recipe for effective targets
      plant_id: ${plant_response.data.id}
    save: recipe_response

  - step: create_recipe_revision
    type: api_post
    endpoint: /api/recipes/${recipe_response.data.id}/revisions
    payload:
      description: Test revision with specific targets
    save: revision_response

  - step: add_phase_with_targets
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/phases
    payload:
      phase_index: 0
      name: Test Phase
      duration_hours: 24
      ph_target: 6.0      # Recipe target
      ph_min: 5.8
      ph_max: 6.2
      ec_target: 1.5      # Recipe target
      ec_min: 1.4
      ec_max: 1.6
      temp_air_target: 22.0  # Recipe target
      irrigation_mode: SUBSTRATE
      irrigation_interval_sec: 3600
      irrigation_duration_sec: 300

  - step: publish_revision
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/publish
    payload: {}

  # Создаем и запускаем цикл
  - step: create_grow_cycle
    type: api_post
    endpoint: /api/zones/${zone_id}/grow-cycles
    payload:
      recipe_revision_id: ${revision_response.data.id}
      plant_id: ${plant_response.data.id}
      start_immediately: true
    save: cycle_response

  - step: set_cycle_id
    type: set
    cycle_id: ${cycle_response.data.id}

  - step: wait_for_effective_targets
    type: sleep
    seconds: 2

  # Проверяем начальные effective-targets (должны соответствовать recipe)
  - step: fetch_initial_effective_targets
    type: api_get
    endpoint: /api/zones/${zone_id}/effective-targets
    save: initial_effective_targets

  # Override targets через overrides
  - step: override_ph_target
    type: database_execute
    query: |
      INSERT INTO grow_cycle_overrides (
        grow_cycle_id, parameter, value_type, value, is_active, created_at, updated_at
      )
      VALUES (:cycle_id, 'ph.target', 'decimal', '6.5', true, NOW(), NOW());
    params:
      cycle_id: ${cycle_id}

  - step: override_ec_target
    type: database_execute
    query: |
      INSERT INTO grow_cycle_overrides (
        grow_cycle_id, parameter, value_type, value, is_active, created_at, updated_at
      )
      VALUES (:cycle_id, 'ec.target', 'decimal', '1.8', true, NOW(), NOW());
    params:
      cycle_id: ${cycle_id}

  - step: override_temp_target
    type: database_execute
    query: |
      INSERT INTO grow_cycle_overrides (
        grow_cycle_id, parameter, value_type, value, is_active, created_at, updated_at
      )
      VALUES (:cycle_id, 'climate_request.temp_air_target', 'decimal', '25.0', true, NOW(), NOW());
    params:
      cycle_id: ${cycle_id}

  - step: wait_for_override_effective
    type: sleep
    seconds: 2

  # Проверяем финальные effective-targets (должны быть override значения)
  - step: fetch_final_effective_targets
    type: api_get
    endpoint: /api/zones/${zone_id}/effective-targets
    save: final_effective_targets

assertions:
  # Проверка 1: Начальные effective-targets соответствуют recipe
  - name: initial_targets_from_recipe
    type: json_assertion
    source: initial_effective_targets
    path: data.targets
    expected:
      - field: ph.target
        operator: equals
        value: 6
      - field: ec.target
        operator: equals
        value: 1.5
      - field: climate_request.temp_air_target
        operator: equals
        value: 22

  # Проверка 2: Финальные effective-targets соответствуют override
  - name: final_targets_from_override
    type: json_assertion
    source: final_effective_targets
    path: data.targets
    expected:
      - field: ph.target
        operator: equals
        value: 6.5
      - field: ec.target
        operator: equals
        value: 1.8
      - field: climate_request.temp_air_target
        operator: equals
        value: 25

  # Проверка 3: AE использует effective-targets (косвенно через команды)
  - name: ae_uses_effective_targets
    type: database_query
    query: |
      SELECT COUNT(*) as command_count
      FROM commands
      WHERE zone_id = :zone_id
      AND cmd IN ('dose', 'run_pump')
      AND params->>'type' IN ('add_acid', 'add_base', 'add_nutrients', 'dilute')
      AND created_at > NOW() - INTERVAL '30 seconds'
    params:
      zone_id: ${zone_id}
    expected:
      - field: command_count
        operator: greater_than
        value: 0
    optional: true

cleanup:
  - step: abort_cycle
    type: api_post
    endpoint: /api/grow-cycles/${cycle_id}/abort
    payload: {}
    optional: true

  - step: delete_overrides
    type: database_execute
    query: |
      DELETE FROM grow_cycle_overrides
      WHERE grow_cycle_id = :cycle_id;
    params:
      cycle_id: ${cycle_id}
    optional: true

  - step: delete_recipe
    type: api_delete
    endpoint: /api/recipes/${recipe_response.data.id}
    optional: true

  - step: delete_plant
    type: api_delete
    endpoint: /api/plants/${plant_response.data.id}
    optional: true
