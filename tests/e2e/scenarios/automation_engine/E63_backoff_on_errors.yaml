# E63: Backoff on Errors - degraded mode (через test hook)
# DoD: серия ошибок → degraded mode → контроллеры отключены

name: E63_backoff_on_errors
description: |
  Проверяет переход в degraded mode и отключение контроллеров:
  - Сначала климат работает (есть команда нагрева)
  - Затем принудительно выставляем error_streak >= threshold
  - В degraded mode команды не создаются
  - После reset_backoff команды снова появляются

setup:
  node_sim:
    config:
      mqtt:
        host: ${MQTT_HOST:-localhost}
        port: ${MQTT_PORT:-1884}
      node:
        gh_uid: gh-test-1
        zone_uid: zn-test-1
        node_uid: nd-ph-esp32una
        hardware_id: esp32-test-001
        node_type: ph
        mode: configured
        channels:
          - air_temp_c
        actuators:
          - heater
      telemetry:
        interval_seconds: 60.0

actions:
  - step: stop_node_simulator_initial
    type: stop_simulator
    wait_seconds: 5
    optional: true

  - step: start_node_simulator
    type: start_simulator
    config_ref: node_sim.config
    wait_seconds: 3
    optional: true

  - step: set_test_uids
    type: set
    test_gh_uid: ${setup.node_sim.config.node.gh_uid}
    test_zone_uid: ${setup.node_sim.config.node.zone_uid}
    test_node_uid: ${setup.node_sim.config.node.node_uid}

  - step: set_zone_id_from_uid
    type: database_query
    query: |
      SELECT id
      FROM zones
      WHERE uid = :zone_uid
      LIMIT 1
    params:
      zone_uid: ${test_zone_uid}
    save: zone_row

  - step: set_node_id_from_uid
    type: database_query
    query: |
      SELECT id AS node_id
      FROM nodes
      WHERE uid = :node_uid
      LIMIT 1
    params:
      node_uid: ${test_node_uid}
    save: node_row

  - step: set_ids
    type: set
    zone_id: ${zone_row.0.id}
    node_id: ${node_row.0.node_id}

  - step: ensure_main_pump_role
    type: database_execute
    query: |
      UPDATE node_channels
      SET config = COALESCE(config, '{}'::jsonb) || jsonb_build_object('zone_role', 'main_pump')
      WHERE node_id = :node_id
        AND channel = 'heater';
    params:
      node_id: ${node_id}

  - step: ensure_drain_role
    type: database_execute
    query: |
      UPDATE node_channels
      SET config = COALESCE(config, '{}'::jsonb) || jsonb_build_object('zone_role', 'drain')
      WHERE node_id = :node_id
        AND channel = 'air_temp_c';
    params:
      node_id: ${node_id}

  - step: cleanup_old_cycles
    type: database_execute
    query: |
      DELETE FROM grow_cycles
      WHERE zone_id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: set_capabilities_without_ph_ec_requirements
    type: database_execute
    query: |
      UPDATE zones
      SET capabilities = jsonb_build_object(
        'ph_control', false,
        'ec_control', false,
        'climate_control', true,
        'light_control', true,
        'irrigation_control', true,
        'recirculation', true,
        'flow_sensor', true
      )
      WHERE id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: ensure_primary_node_online
    type: database_execute
    query: |
      UPDATE nodes
      SET status = 'online',
          last_seen_at = COALESCE(last_seen_at, NOW()),
          updated_at = NOW()
      WHERE id = :node_id;
    params:
      node_id: ${node_id}

  - step: ensure_zone_readiness_bindings
    type: database_execute
    query: |
      UPDATE node_channels nc
      SET config = COALESCE(nc.config, '{}'::jsonb) || jsonb_build_object(
        'zone_role',
        CASE
          WHEN nc.channel = 'main_pump' THEN 'main_pump'
          WHEN nc.channel = 'drain_pump' THEN 'drain'
          ELSE nc.config->>'zone_role'
        END
      )
      FROM nodes n
      WHERE n.id = nc.node_id
        AND n.id = :node_id
        AND n.zone_id = :zone_id
        AND nc.channel IN ('main_pump', 'drain_pump');
    params:
      zone_id: ${zone_id}
      node_id: ${node_id}

  - step: ensure_main_and_drain_bindings
    type: database_execute
    query: |
      WITH zone_ctx AS (
        SELECT :zone_id::bigint AS zone_id
      ),
      ensure_instances AS (
        INSERT INTO infrastructure_instances (owner_type, owner_id, asset_type, label, required, created_at, updated_at)
        SELECT 'zone', zc.zone_id, m.asset_type, m.label, true, NOW(), NOW()
        FROM zone_ctx zc
        CROSS JOIN (
          VALUES
            ('PUMP', 'E2E Main Pump'),
            ('DRAIN', 'E2E Drain Pump')
        ) AS m(asset_type, label)
        WHERE NOT EXISTS (
          SELECT 1
          FROM infrastructure_instances ii
          WHERE ii.owner_type = 'zone'
            AND ii.owner_id = zc.zone_id
            AND ii.label = m.label
        )
        RETURNING id
      ),
      upsert_bindings AS (
        INSERT INTO channel_bindings (infrastructure_instance_id, node_channel_id, direction, role, created_at, updated_at)
        SELECT
          ii.id,
          nc.id,
          'actuator',
          m.role,
          NOW(),
          NOW()
        FROM zone_ctx zc
        JOIN nodes n
          ON n.id = :node_id
         AND n.zone_id = zc.zone_id
        JOIN (
          VALUES
            ('main_pump', 'main_pump', 'E2E Main Pump'),
            ('drain_pump', 'drain', 'E2E Drain Pump')
        ) AS m(channel, role, label)
          ON TRUE
        JOIN node_channels nc
          ON nc.node_id = n.id
         AND nc.channel = m.channel
        JOIN infrastructure_instances ii
          ON ii.owner_type = 'zone'
         AND ii.owner_id = zc.zone_id
         AND ii.label = m.label
        ON CONFLICT (node_channel_id) DO UPDATE SET
          infrastructure_instance_id = EXCLUDED.infrastructure_instance_id,
          direction = EXCLUDED.direction,
          role = EXCLUDED.role,
          updated_at = NOW()
        RETURNING node_channel_id
      )
      SELECT 1;
    params:
      zone_id: ${zone_id}
      node_id: ${node_id}

  - step: verify_main_and_drain_bindings_online
    type: db.wait
    query: |
      SELECT cb.role
      FROM channel_bindings cb
      JOIN node_channels nc ON nc.id = cb.node_channel_id
      JOIN nodes n ON n.id = nc.node_id
      WHERE n.zone_id = :zone_id
        AND n.id = :node_id
        AND n.status = 'online'
        AND cb.role IN ('main_pump', 'drain')
      ORDER BY cb.role
    params:
      zone_id: ${zone_id}
      node_id: ${node_id}
    expected_rows: 2
    timeout: 15.0

  # Создаем рецепт с климатическими targets
  - step: create_plant
    type: api_post
    endpoint: /api/plants
    payload:
      name: test-plant-e63-${TIMESTAMP_S}
      scientific_name: Test Plant
    save: plant_response

  - step: create_recipe
    type: api_post
    endpoint: /api/recipes
    payload:
      name: test-recipe-e63-${TIMESTAMP_S}
      description: Test recipe for E63
      plant_id: ${plant_response.data.id}
    save: recipe_response

  - step: create_revision
    type: api_post
    endpoint: /api/recipes/${recipe_response.data.id}/revisions
    payload:
      description: Test revision for E63
    save: revision_response

  - step: add_phase
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/phases
    payload:
      phase_index: 0
      name: Test Phase
      duration_hours: 24
      temp_air_target: 30.0
      irrigation_mode: SUBSTRATE

  - step: publish_revision
    type: api_post
    endpoint: /api/recipe-revisions/${revision_response.data.id}/publish
    payload: {}

  - step: create_cycle
    type: api_post
    endpoint: /api/zones/${zone_id}/grow-cycles
    payload:
      recipe_revision_id: ${revision_response.data.id}
      plant_id: ${plant_response.data.id}
      start_immediately: true
    save: cycle_response

  - step: set_cycle_id
    type: set
    cycle_id: ${cycle_response.data.id}

  - step: wait_for_effective_targets
    type: sleep
    seconds: 2

  - step: enable_capabilities
    type: database_execute
    query: |
      UPDATE zones
      SET capabilities = jsonb_build_object(
        'climate_control', true
      )
      WHERE id = :zone_id;
    params:
      zone_id: ${zone_id}

  - step: ensure_heater_infrastructure
    type: database_execute
    query: |
      WITH zone_ctx AS (
        SELECT :zone_id::bigint AS zone_id
      )
      INSERT INTO infrastructure_instances (
        owner_type,
        owner_id,
        asset_type,
        label,
        required,
        created_at,
        updated_at
      )
      SELECT
        'zone',
        zc.zone_id,
        'HEATER',
        'E2E Heater',
        true,
        NOW(),
        NOW()
      FROM zone_ctx zc
      WHERE NOT EXISTS (
        SELECT 1
        FROM infrastructure_instances
        WHERE owner_type = 'zone'
          AND owner_id = zc.zone_id
          AND asset_type = 'HEATER'
      );
    params:
      zone_id: ${zone_id}

  # Привязка heater
  - step: fetch_heater_channel
    type: database_query
    query: |
      SELECT id AS node_channel_id
      FROM node_channels
      WHERE node_id = :node_id
        AND channel = 'heater'
      LIMIT 1
    params:
      node_id: ${node_id}
    save: heater_channel_row

  - step: fetch_heater_infra
    type: database_query
    query: |
      SELECT id AS infra_id
      FROM infrastructure_instances
      WHERE owner_type = 'zone'
        AND owner_id = :zone_id
        AND asset_type = 'HEATER'
      LIMIT 1
    params:
      zone_id: ${zone_id}
    save: heater_infra_row
    expected_rows: 1

  - step: upsert_heater_binding
    type: database_execute
    query: |
      INSERT INTO channel_bindings (
        infrastructure_instance_id, node_channel_id, direction, role, created_at, updated_at
      )
      VALUES (:infra_id, :node_channel_id, 'actuator', 'heater', NOW(), NOW())
      ON CONFLICT (node_channel_id) DO UPDATE
      SET infrastructure_instance_id = EXCLUDED.infrastructure_instance_id,
          direction = EXCLUDED.direction,
          role = EXCLUDED.role,
          updated_at = NOW();
    params:
      infra_id: ${heater_infra_row.0.infra_id}
      node_channel_id: ${heater_channel_row.0.node_channel_id}

  - step: reset_backoff
    type: ae_test_hook
    zone_id: ${zone_id}
    action: reset_backoff

  # Базовая проверка — климат работает
  - step: baseline_window_open
    type: database_query
    query: |
      SELECT NOW() as ts
    save: baseline_start_ts

  - step: publish_temp_low_baseline
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/air_temp_c/telemetry
    payload:
      metric_type: TEMPERATURE
      value: 29.0
    qos: 1
    wait_seconds: 2

  - step: wait_for_baseline_command
    type: db.wait
    query: |
      SELECT id AS cmd_id, created_at AS cmd_ts
      FROM commands
      WHERE zone_id = :zone_id
        AND cmd = 'set_relay'
        AND channel = 'heater'
        AND params->>'state' = 'true'
        AND created_at >= :baseline_start_ts
      ORDER BY created_at DESC
      LIMIT 1
    params:
      zone_id: ${zone_id}
      baseline_start_ts: ${baseline_start_ts.0.ts}
    expected_rows: 1
    timeout: 45.0
    save: baseline_command_row

  # Включаем degraded mode через test hook
  - step: degraded_timestamp
    type: database_query
    query: |
      SELECT NOW() as ts
    save: degraded_ts

  - step: set_degraded_state
    type: ae_test_hook
    zone_id: ${zone_id}
    action: set_state
    state:
      error_streak: 3
      next_allowed_run_at: null
      degraded_alert_active: false

  - step: publish_temp_low_degraded
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/air_temp_c/telemetry
    payload:
      metric_type: TEMPERATURE
      value: 29.2
    qos: 1
    wait_seconds: 2

  - step: wait_for_degraded_cycle
    type: sleep
    seconds: 45

  - step: snapshot_pre_reset_command_state
    type: database_query
    query: |
      SELECT COALESCE(MAX(id), :baseline_cmd_id) AS max_cmd_id_before_reset
      FROM commands
      WHERE zone_id = :zone_id
        AND cmd = 'set_relay'
        AND channel = 'heater'
        AND params->>'state' = 'true'
    params:
      zone_id: ${zone_id}
      baseline_cmd_id: ${baseline_command_row.0.cmd_id}
    save: pre_reset_cmd_snapshot

  - step: reset_backoff_after_degraded
    type: ae_test_hook
    zone_id: ${zone_id}
    action: reset_backoff

  - step: reset_timestamp
    type: database_query
    query: |
      SELECT NOW() as ts
    save: reset_ts

  - step: publish_temp_low_after_reset
    type: mqtt_publish
    topic: hydro/${test_gh_uid}/${test_zone_uid}/${test_node_uid}/air_temp_c/telemetry
    payload:
      metric_type: TEMPERATURE
      value: 28.9
    qos: 1
    wait_seconds: 2

  - step: wait_for_post_reset_command
    type: sleep
    seconds: 45

assertions:
  - name: degraded_mode_event_created
    type: database_query
    optional: true
    query: |
      SELECT COUNT(*) as event_count
      FROM zone_events
      WHERE zone_id = :zone_id
        AND type = 'ZONE_DEGRADED_MODE'
        AND created_at >= :degraded_ts
    params:
      zone_id: ${zone_id}
      degraded_ts: ${degraded_ts.0.ts}
    expected:
      - field: event_count
        operator: greater_than
        value: 0

  - name: degraded_mode_infra_alert_upserted
    type: database_query
    optional: true
    query: |
      SELECT COUNT(*) as alert_count
      FROM alerts
      WHERE zone_id = :zone_id
        AND source = 'infra'
        AND code = 'infra_zone_degraded_mode'
        AND status = 'ACTIVE'
        AND created_at >= :degraded_ts
    params:
      zone_id: ${zone_id}
      degraded_ts: ${degraded_ts.0.ts}
    expected:
      - field: alert_count
        operator: greater_than
        value: 0

  - name: baseline_heater_command_created
    type: database_query
    query: |
      SELECT COUNT(*) as cmd_count
      FROM commands
      WHERE id = :baseline_cmd_id
    params:
      baseline_cmd_id: ${baseline_command_row.0.cmd_id}
    expected:
      - field: cmd_count
        operator: greater_than
        value: 0

  - name: no_commands_in_degraded_mode
    type: database_query
    query: |
      SELECT GREATEST(:max_cmd_id_before_reset - :baseline_cmd_id, 0) AS cmd_count
    params:
      baseline_cmd_id: ${baseline_command_row.0.cmd_id}
      max_cmd_id_before_reset: ${pre_reset_cmd_snapshot.0.max_cmd_id_before_reset}
    expected:
      - field: cmd_count
        operator: equals
        value: 0

  - name: commands_after_reset
    type: database_query
    query: |
      SELECT COUNT(*) as cmd_count
      FROM commands
      WHERE zone_id = :zone_id
        AND cmd = 'set_relay'
        AND channel = 'heater'
        AND params->>'state' = 'true'
        AND id > :max_cmd_id_before_reset
    params:
      zone_id: ${zone_id}
      max_cmd_id_before_reset: ${pre_reset_cmd_snapshot.0.max_cmd_id_before_reset}
    expected:
      - field: cmd_count
        operator: greater_than
        value: 0

  - name: zone_recovered_event_after_reset
    type: database_query
    optional: true
    query: |
      SELECT COUNT(*) as event_count
      FROM zone_events
      WHERE zone_id = :zone_id
        AND type = 'ZONE_RECOVERED'
        AND created_at > :degraded_ts
    params:
      zone_id: ${zone_id}
      degraded_ts: ${degraded_ts.0.ts}
    expected:
      - field: event_count
        operator: greater_than
        value: 0

cleanup:
  - step: abort_cycle
    type: api_post
    endpoint: /api/grow-cycles/${cycle_id}/abort
    payload: {}
    optional: true

  - step: clear_state_override
    type: ae_test_hook
    zone_id: ${zone_id}
    action: reset_backoff
    optional: true

  - step: delete_recipe
    type: api_delete
    endpoint: /api/recipes/${recipe_response.data.id}
    optional: true

  - step: delete_plant
    type: api_delete
    endpoint: /api/plants/${plant_response.data.id}
    optional: true
